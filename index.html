<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FreeLattice — Your AI. Your Rules. Your Machine. v2.5</title>
<meta name="description" content="Free, open-source AI agent for everyone. Persistent memory, file system access, GitHub integration, and self-improving behavior. Community-built and community-owned.">
<style>
/* ============================================
   FreeLattice v2.5 — Styles
   Peaceful, gentle dark theme with golden/amber accents
   φ-salt encryption, input sanitization, memory integrity
   Multi-conversation management + Smart Context Management
   + Mesh Network (Layer 1) — P2P Knowledge Sharing
   ============================================ */

:root {
  --bg-primary: #0f1117;
  --bg-secondary: #161822;
  --bg-tertiary: #1c1f2e;
  --bg-card: #1a1d2b;
  --bg-input: #12141e;
  --border: #2a2d3e;
  --border-focus: #c9a84c;
  --text-primary: #e8e4dc;
  --text-secondary: #a09b8e;
  --text-muted: #6b6760;
  --accent: #c9a84c;
  --accent-soft: #c9a84c33;
  --accent-glow: #c9a84c22;
  --accent-hover: #d4b45e;
  --success: #6abf69;
  --warning: #d4a843;
  --error: #c75050;
  --radius: 12px;
  --radius-sm: 8px;
  --shadow: 0 2px 12px rgba(0,0,0,0.3);
  --transition: 0.25s ease;
  --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
  --sidebar-width: 240px;
}

*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  scroll-behavior: smooth;
  font-size: 16px;
}

body {
  font-family: var(--font);
  background: var(--bg-primary);
  color: var(--text-primary);
  line-height: 1.65;
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
}

/* Scrollbar */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg-primary); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--accent); }

/* Layout */
.container {
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
}

/* ---- Header ---- */
header {
  text-align: center;
  padding: 40px 20px 20px;
  border-bottom: 1px solid var(--border);
}

header h1 {
  font-size: 2.4rem;
  font-weight: 300;
  letter-spacing: 0.15em;
  color: var(--accent);
  margin-bottom: 6px;
}

header .tagline {
  font-size: 0.95rem;
  color: var(--text-secondary);
  font-weight: 400;
  letter-spacing: 0.06em;
}

header .mantra {
  font-size: 0.8rem;
  color: var(--text-muted);
  font-style: italic;
  margin-top: 10px;
  opacity: 0.8;
}

/* ---- Music Toggle ---- */
.music-toggle {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 1000;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 50%;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: var(--transition);
  color: var(--text-muted);
  font-size: 1.1rem;
}

.music-toggle:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.music-toggle.active {
  color: var(--accent);
  border-color: var(--accent);
  box-shadow: 0 0 12px var(--accent-soft);
}

/* ---- Welcome Modal ---- */
.welcome-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 2000;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  backdrop-filter: blur(4px);
}

.welcome-overlay.hidden { display: none; }

.welcome-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  max-width: 560px;
  width: 100%;
  padding: 40px 36px;
  text-align: center;
  box-shadow: var(--shadow);
}

.welcome-card h2 {
  font-size: 1.8rem;
  font-weight: 300;
  color: var(--accent);
  letter-spacing: 0.1em;
  margin-bottom: 16px;
}

.welcome-card p {
  color: var(--text-secondary);
  font-size: 0.95rem;
  margin-bottom: 14px;
  line-height: 1.7;
}

.welcome-card .highlight {
  color: var(--accent);
  font-weight: 500;
}

.welcome-card button {
  margin-top: 20px;
  padding: 12px 36px;
  background: var(--accent);
  color: var(--bg-primary);
  border: none;
  border-radius: var(--radius-sm);
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: var(--transition);
  letter-spacing: 0.03em;
}

.welcome-card button:hover {
  background: var(--accent-hover);
  transform: translateY(-1px);
}

/* ---- Tab Navigation ---- */
.tab-nav {
  display: flex;
  gap: 0;
  border-bottom: 1px solid var(--border);
  margin-top: 8px;
  overflow-x: auto;
}

.tab-btn {
  padding: 14px 28px;
  background: transparent;
  border: none;
  border-bottom: 2px solid transparent;
  color: var(--text-muted);
  font-size: 0.88rem;
  font-weight: 500;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
  letter-spacing: 0.03em;
  white-space: nowrap;
  flex-shrink: 0;
}

.tab-btn:hover {
  color: var(--text-secondary);
  background: var(--accent-glow);
}

.tab-btn.active {
  color: var(--accent);
  border-bottom-color: var(--accent);
}

.tab-panel {
  display: none;
}

.tab-panel.active {
  display: block;
}

/* ---- Sections ---- */
.section {
  padding: 24px 0;
  border-bottom: 1px solid var(--border);
}

.section:last-of-type { border-bottom: none; }

.section-title {
  font-size: 0.8rem;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--accent);
  margin-bottom: 16px;
  font-weight: 600;
}

/* ---- Form Elements ---- */
.form-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin-bottom: 16px;
}

@media (max-width: 600px) {
  .form-row { grid-template-columns: 1fr; }
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.form-group label {
  font-size: 0.82rem;
  color: var(--text-secondary);
  font-weight: 500;
  letter-spacing: 0.02em;
}

.form-group select,
.form-group input[type="text"],
.form-group input[type="password"],
.form-group textarea {
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 14px;
  color: var(--text-primary);
  font-size: 0.9rem;
  font-family: var(--font);
  transition: var(--transition);
  outline: none;
  width: 100%;
}

.form-group select:focus,
.form-group input:focus,
.form-group textarea:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

.form-group select { cursor: pointer; }

.form-group select option {
  background: var(--bg-secondary);
  color: var(--text-primary);
}

.hint {
  font-size: 0.78rem;
  color: var(--text-muted);
  line-height: 1.5;
  margin-top: 2px;
}

.hint a {
  color: var(--accent);
  text-decoration: none;
}

.hint a:hover { text-decoration: underline; }

/* ---- Toggle Switch ---- */
.toggle-row {
  display: flex;
  align-items: center;
  gap: 14px;
  margin-bottom: 16px;
}

.toggle-label {
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.toggle-label.active { color: var(--accent); font-weight: 500; }

.toggle-switch {
  position: relative;
  width: 52px;
  height: 28px;
  flex-shrink: 0;
}

.toggle-switch input { opacity: 0; width: 0; height: 0; }

.toggle-slider {
  position: absolute;
  inset: 0;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 14px;
  cursor: pointer;
  transition: var(--transition);
}

.toggle-slider::before {
  content: '';
  position: absolute;
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background: var(--text-muted);
  top: 2px;
  left: 3px;
  transition: var(--transition);
}

.toggle-switch input:checked + .toggle-slider {
  background: var(--accent-soft);
  border-color: var(--accent);
}

.toggle-switch input:checked + .toggle-slider::before {
  background: var(--accent);
  transform: translateX(23px);
}

/* ---- Privacy Info ---- */
.privacy-info {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px 18px;
  margin-top: 10px;
  font-size: 0.82rem;
  color: var(--text-secondary);
  line-height: 1.6;
}

/* ---- Ollama Instructions ---- */
.ollama-instructions {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 18px;
  margin-top: 12px;
  font-size: 0.85rem;
  color: var(--text-secondary);
  line-height: 1.7;
}

.ollama-instructions code {
  background: var(--bg-primary);
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 0.82rem;
  color: var(--accent);
  font-family: 'Courier New', monospace;
}

.ollama-instructions h4 {
  color: var(--accent);
  font-size: 0.88rem;
  margin-bottom: 8px;
  font-weight: 600;
}

.hidden { display: none !important; }

/* ---- File Drop Zone ---- */
.drop-zone {
  border: 2px dashed var(--border);
  border-radius: var(--radius);
  padding: 30px 20px;
  text-align: center;
  cursor: pointer;
  transition: var(--transition);
  margin-top: 8px;
  position: relative;
}

.drop-zone:hover,
.drop-zone.dragover {
  border-color: var(--accent);
  background: var(--accent-glow);
}

.drop-zone-text {
  color: var(--text-muted);
  font-size: 0.88rem;
}

.drop-zone-text .icon {
  font-size: 1.6rem;
  display: block;
  margin-bottom: 8px;
}

.drop-zone input[type="file"] {
  position: absolute;
  inset: 0;
  opacity: 0;
  cursor: pointer;
}

.file-list {
  margin-top: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.file-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 8px 14px;
  font-size: 0.82rem;
}

.file-item .file-name {
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
  margin-right: 10px;
}

.file-item .file-size {
  color: var(--text-muted);
  font-size: 0.75rem;
  margin-right: 10px;
  flex-shrink: 0;
}

.file-item .remove-file {
  background: none;
  border: none;
  color: var(--error);
  cursor: pointer;
  font-size: 1rem;
  padding: 0 4px;
  transition: var(--transition);
  flex-shrink: 0;
}

.file-item .remove-file:hover { opacity: 0.7; }

/* ---- Chat Interface ---- */
.chat-container {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  overflow: hidden;
  margin-top: 12px;
}

.chat-messages {
  height: 450px;
  overflow-y: auto;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 14px;
}

.chat-message {
  max-width: 85%;
  padding: 12px 16px;
  border-radius: var(--radius-sm);
  font-size: 0.9rem;
  line-height: 1.65;
  word-wrap: break-word;
  white-space: pre-wrap;
}

.chat-message.user {
  align-self: flex-end;
  background: var(--accent-soft);
  color: var(--text-primary);
  border-bottom-right-radius: 4px;
}

.chat-message.assistant {
  align-self: flex-start;
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border-bottom-left-radius: 4px;
}

.chat-message.system {
  align-self: center;
  background: transparent;
  color: var(--text-muted);
  font-size: 0.82rem;
  font-style: italic;
  text-align: center;
  max-width: 100%;
}

.chat-message .msg-label {
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
  margin-bottom: 4px;
  display: block;
}

.chat-message.user .msg-label { text-align: right; }

/* Save to workspace button inside AI messages */
.save-to-workspace-btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  margin-top: 8px;
  padding: 6px 14px;
  background: var(--bg-input);
  border: 1px solid var(--accent);
  border-radius: var(--radius-sm);
  color: var(--accent);
  font-size: 0.78rem;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
}

.save-to-workspace-btn:hover {
  background: var(--accent-soft);
}

.save-to-workspace-btn.saved {
  border-color: var(--success);
  color: var(--success);
  cursor: default;
}

/* System prompt suggestion notification */
.prompt-suggestion-bar {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  margin-top: 8px;
  background: var(--accent-glow);
  border: 1px solid var(--accent);
  border-radius: var(--radius-sm);
  font-size: 0.82rem;
  color: var(--text-secondary);
}

.prompt-suggestion-bar button {
  padding: 4px 12px;
  border-radius: var(--radius-sm);
  font-size: 0.78rem;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
  border: 1px solid var(--border);
  background: var(--bg-input);
  color: var(--text-secondary);
}

.prompt-suggestion-bar button.approve {
  background: var(--accent);
  color: var(--bg-primary);
  border-color: var(--accent);
  font-weight: 600;
}

.chat-input-row {
  display: flex;
  border-top: 1px solid var(--border);
}

.chat-input-row textarea {
  flex: 1;
  background: var(--bg-input);
  border: none;
  padding: 14px 18px;
  color: var(--text-primary);
  font-size: 0.9rem;
  font-family: var(--font);
  resize: none;
  outline: none;
  min-height: 48px;
  max-height: 120px;
  line-height: 1.5;
}

.chat-input-row textarea::placeholder { color: var(--text-muted); }

.chat-input-row button:not(.mic-btn) {
  background: var(--accent);
  color: var(--bg-primary);
  border: none;
  padding: 14px 22px;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: var(--transition);
  letter-spacing: 0.02em;
}

.chat-input-row button:not(.mic-btn):hover { background: var(--accent-hover); }

.chat-input-row button:not(.mic-btn):disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* ---- Status Bar ---- */
.status-bar {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 18px;
  background: var(--bg-tertiary);
  font-size: 0.75rem;
  color: var(--text-muted);
  border-top: 1px solid var(--border);
}

.status-dot {
  width: 7px;
  height: 7px;
  border-radius: 50%;
  background: var(--text-muted);
  flex-shrink: 0;
}

.status-dot.ready { background: var(--success); }
.status-dot.working { background: var(--warning); animation: pulse 1s infinite; }
.status-dot.error { background: var(--error); }

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* ---- How It Works / Expandable ---- */
.expandable {
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  overflow: hidden;
  margin-top: 12px;
}

.expandable-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 18px;
  background: var(--bg-tertiary);
  cursor: pointer;
  transition: var(--transition);
  user-select: none;
}

.expandable-header:hover { background: var(--bg-card); }

.expandable-header h3 {
  font-size: 0.88rem;
  font-weight: 500;
  color: var(--text-secondary);
}

.expandable-header .arrow {
  color: var(--text-muted);
  transition: transform 0.3s ease;
  font-size: 0.8rem;
}

.expandable-header.open .arrow { transform: rotate(180deg); }

.expandable-body {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s ease;
}

.expandable-body.open { max-height: 5000px; }

.expandable-content {
  padding: 20px;
  font-size: 0.85rem;
  color: var(--text-secondary);
  line-height: 1.75;
}

.expandable-content h4 {
  color: var(--accent);
  font-size: 0.88rem;
  margin: 16px 0 6px;
  font-weight: 600;
}

.expandable-content h4:first-child { margin-top: 0; }

.expandable-content p { margin-bottom: 10px; }

.expandable-content a {
  color: var(--accent);
  text-decoration: none;
}

.expandable-content a:hover { text-decoration: underline; }

.expandable-content code {
  background: var(--bg-primary);
  padding: 2px 7px;
  border-radius: 4px;
  font-size: 0.82rem;
  color: var(--accent);
}

/* ---- Feature Suggestion ---- */
.suggest-btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 20px;
  color: var(--text-secondary);
  font-size: 0.85rem;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
  margin-top: 12px;
}

.suggest-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.suggest-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 2000;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  backdrop-filter: blur(4px);
}

.suggest-overlay.hidden { display: none; }

.suggest-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  max-width: 500px;
  width: 100%;
  padding: 32px;
  box-shadow: var(--shadow);
}

.suggest-card h3 {
  font-size: 1.1rem;
  color: var(--accent);
  font-weight: 400;
  margin-bottom: 8px;
}

.suggest-card p {
  font-size: 0.85rem;
  color: var(--text-muted);
  margin-bottom: 16px;
  line-height: 1.6;
}

.suggest-card textarea {
  width: 100%;
  min-height: 100px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 12px;
  color: var(--text-primary);
  font-size: 0.9rem;
  font-family: var(--font);
  resize: vertical;
  outline: none;
  transition: var(--transition);
}

.suggest-card textarea:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

.suggest-actions {
  display: flex;
  gap: 10px;
  margin-top: 16px;
  justify-content: flex-end;
}

.suggest-actions button {
  padding: 10px 22px;
  border-radius: var(--radius-sm);
  font-size: 0.85rem;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
}

.btn-cancel {
  background: transparent;
  border: 1px solid var(--border);
  color: var(--text-muted);
}

.btn-cancel:hover { border-color: var(--text-secondary); color: var(--text-secondary); }

.btn-submit {
  background: var(--accent);
  border: none;
  color: var(--bg-primary);
  font-weight: 600;
}

.btn-submit:hover { background: var(--accent-hover); }

.suggest-success {
  text-align: center;
  padding: 20px 0;
}

.suggest-success .check {
  font-size: 2rem;
  color: var(--success);
  margin-bottom: 12px;
}

.suggest-success p {
  color: var(--text-secondary);
  font-size: 0.9rem;
  line-height: 1.7;
}

.suggest-success .future-note {
  color: var(--text-muted);
  font-size: 0.82rem;
  font-style: italic;
  margin-top: 8px;
}

/* ---- Workspace: File Tree ---- */
.file-tree {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  max-height: 400px;
  overflow-y: auto;
  margin-top: 10px;
}

.file-tree-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 7px 14px;
  font-size: 0.82rem;
  color: var(--text-secondary);
  cursor: pointer;
  transition: var(--transition);
  border-bottom: 1px solid var(--border);
}

.file-tree-item:last-child { border-bottom: none; }

.file-tree-item:hover {
  background: var(--accent-glow);
  color: var(--text-primary);
}

.file-tree-item.active {
  background: var(--accent-soft);
  color: var(--accent);
}

.file-tree-item .ft-icon {
  flex-shrink: 0;
  font-size: 0.9rem;
}

.file-tree-item .ft-name {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
}

.file-tree-item .ft-indent {
  display: inline-block;
}

/* ---- Workspace & GitHub action buttons ---- */
.action-btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 10px 20px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text-secondary);
  font-size: 0.85rem;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
}

.action-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.action-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.action-btn.primary {
  background: var(--accent);
  border-color: var(--accent);
  color: var(--bg-primary);
  font-weight: 600;
}

.action-btn.primary:hover {
  background: var(--accent-hover);
}

.action-row {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 12px;
}

/* ---- Memory Section ---- */
.memory-stats {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  margin-bottom: 14px;
}

.memory-stat {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 18px;
  text-align: center;
  flex: 1;
  min-width: 120px;
}

.memory-stat .stat-value {
  font-size: 1.4rem;
  font-weight: 300;
  color: var(--accent);
}

.memory-stat .stat-label {
  font-size: 0.72rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.06em;
  margin-top: 2px;
}

/* ---- System Prompt Editor ---- */
.system-prompt-editor textarea {
  width: 100%;
  min-height: 180px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px;
  color: var(--text-primary);
  font-size: 0.85rem;
  font-family: 'Courier New', monospace;
  line-height: 1.6;
  resize: vertical;
  outline: none;
  transition: var(--transition);
}

.system-prompt-editor textarea:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

/* ---- Memory Summary Editor ---- */
.memory-summary-editor textarea {
  width: 100%;
  min-height: 120px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px;
  color: var(--text-primary);
  font-size: 0.85rem;
  font-family: var(--font);
  line-height: 1.6;
  resize: vertical;
  outline: none;
  transition: var(--transition);
}

.memory-summary-editor textarea:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

/* ---- GitHub connected info ---- */
.gh-connected {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  background: var(--bg-tertiary);
  border: 1px solid var(--success);
  border-radius: var(--radius-sm);
  margin-top: 10px;
  font-size: 0.85rem;
  color: var(--success);
}

.gh-connected .gh-user {
  font-weight: 600;
}

/* ---- Notification Toast ---- */
.toast {
  position: fixed;
  bottom: 80px;
  right: 20px;
  z-index: 3000;
  background: var(--bg-card);
  border: 1px solid var(--accent);
  border-radius: var(--radius-sm);
  padding: 12px 20px;
  font-size: 0.85rem;
  color: var(--text-primary);
  box-shadow: var(--shadow);
  transform: translateY(20px);
  opacity: 0;
  transition: all 0.3s ease;
  pointer-events: none;
  max-width: 360px;
}

.toast.show {
  transform: translateY(0);
  opacity: 1;
  pointer-events: auto;
}

/* ---- Confirmation Dialog ---- */
.confirm-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 2500;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  backdrop-filter: blur(4px);
}

.confirm-overlay.hidden { display: none; }

.confirm-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  max-width: 420px;
  width: 100%;
  padding: 28px;
  text-align: center;
  box-shadow: var(--shadow);
}

.confirm-card h3 {
  color: var(--accent);
  font-weight: 400;
  font-size: 1.1rem;
  margin-bottom: 12px;
}

.confirm-card p {
  color: var(--text-secondary);
  font-size: 0.88rem;
  margin-bottom: 20px;
  line-height: 1.6;
}

.confirm-card .confirm-actions {
  display: flex;
  gap: 10px;
  justify-content: center;
}

/* ---- Footer ---- */
footer {
  text-align: center;
  padding: 30px 20px 40px;
  border-top: 1px solid var(--border);
  margin-top: 10px;
}

footer p {
  font-size: 0.8rem;
  color: var(--text-muted);
  line-height: 1.8;
}

footer .license {
  font-size: 0.72rem;
  margin-top: 8px;
  opacity: 0.6;
}

/* ---- Phi Encryption Indicator ---- */
.phi-indicator {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  font-size: 0.75rem;
  color: var(--success);
  margin-top: 4px;
  opacity: 0.85;
}

.phi-indicator .phi-lock {
  font-size: 0.85rem;
}

/* ---- Chat Disclaimer ---- */
.chat-disclaimer {
  font-size: 0.73rem;
  color: var(--text-muted);
  text-align: center;
  padding: 6px 18px;
  border-top: 1px solid var(--border);
  background: var(--bg-tertiary);
  font-style: italic;
}

/* ---- Voice: Mic Button ---- */
.mic-btn {
  background: var(--bg-tertiary);
  color: var(--text-muted);
  border: none;
  padding: 14px 16px;
  font-size: 1.1rem;
  cursor: pointer;
  transition: var(--transition);
  border-left: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.mic-btn:hover {
  color: var(--accent);
  background: var(--accent-glow);
}

.mic-btn.recording {
  color: var(--error);
  background: rgba(199, 80, 80, 0.12);
  animation: mic-pulse 1.2s ease-in-out infinite;
}

@keyframes mic-pulse {
  0%, 100% { box-shadow: none; }
  50% { box-shadow: inset 0 0 16px rgba(199, 80, 80, 0.25), 0 0 8px rgba(199, 80, 80, 0.15); }
}

/* ---- Voice: Speaker Button on Messages ---- */
.speak-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: none;
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text-muted);
  font-size: 0.82rem;
  padding: 4px 10px;
  cursor: pointer;
  transition: var(--transition);
  margin-top: 6px;
  gap: 4px;
  font-family: var(--font);
}

.speak-btn:hover {
  color: var(--accent);
  border-color: var(--accent);
}

.speak-btn.speaking {
  color: var(--accent);
  border-color: var(--accent);
  background: var(--accent-glow);
  animation: speak-pulse 1.5s ease-in-out infinite;
}

@keyframes speak-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

/* ---- Voice: Settings Section ---- */
.voice-rate-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-top: 6px;
}

.voice-rate-row input[type="range"] {
  flex: 1;
  -webkit-appearance: none;
  appearance: none;
  height: 6px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 3px;
  outline: none;
  cursor: pointer;
}

.voice-rate-row input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: 2px solid var(--bg-primary);
  box-shadow: 0 0 4px rgba(201, 168, 76, 0.3);
}

.voice-rate-row input[type="range"]::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: 2px solid var(--bg-primary);
}

.voice-rate-value {
  font-size: 0.82rem;
  color: var(--accent);
  font-weight: 500;
  min-width: 36px;
  text-align: center;
}

/* ---- Conversation Sidebar ---- */
.chat-layout {
  display: flex;
  gap: 0;
  position: relative;
}

.conv-sidebar {
  width: var(--sidebar-width);
  min-width: var(--sidebar-width);
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: var(--radius) 0 0 var(--radius);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: width 0.3s ease, min-width 0.3s ease, opacity 0.3s ease;
}

.conv-sidebar.collapsed {
  width: 0;
  min-width: 0;
  border: none;
  opacity: 0;
  pointer-events: none;
}

.conv-sidebar-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  background: var(--bg-tertiary);
  flex-shrink: 0;
}

.conv-sidebar-header .conv-title-text {
  font-size: 0.78rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--accent);
  font-weight: 600;
}

.conv-sidebar-header .conv-count {
  font-size: 0.7rem;
  color: var(--text-muted);
  margin-left: 6px;
}

.conv-sidebar-actions {
  display: flex;
  gap: 4px;
}

.conv-sidebar-actions button {
  background: none;
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text-muted);
  font-size: 0.82rem;
  padding: 3px 8px;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
}

.conv-sidebar-actions button:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.conv-search {
  padding: 8px 10px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.conv-search input {
  width: 100%;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 6px 10px;
  color: var(--text-primary);
  font-size: 0.8rem;
  font-family: var(--font);
  outline: none;
  transition: var(--transition);
}

.conv-search input:focus {
  border-color: var(--accent);
}

.conv-search input::placeholder {
  color: var(--text-muted);
}

.conv-list {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
}

.conv-item {
  display: flex;
  flex-direction: column;
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  transition: var(--transition);
  position: relative;
}

.conv-item:hover {
  background: var(--accent-glow);
}

.conv-item.active {
  background: var(--accent-soft);
  border-left: 3px solid var(--accent);
}

.conv-item-top {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 6px;
}

.conv-item-name {
  font-size: 0.82rem;
  color: var(--text-primary);
  font-weight: 500;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
  cursor: pointer;
}

.conv-item.active .conv-item-name {
  color: var(--accent);
}

.conv-item-name input {
  background: var(--bg-input);
  border: 1px solid var(--accent);
  border-radius: 3px;
  color: var(--text-primary);
  font-size: 0.82rem;
  font-family: var(--font);
  padding: 1px 4px;
  width: 100%;
  outline: none;
}

.conv-item-delete {
  background: none;
  border: none;
  color: var(--text-muted);
  font-size: 0.85rem;
  cursor: pointer;
  padding: 0 2px;
  opacity: 0;
  transition: var(--transition);
  flex-shrink: 0;
}

.conv-item:hover .conv-item-delete {
  opacity: 1;
}

.conv-item-delete:hover {
  color: var(--error);
}

.conv-item-preview {
  font-size: 0.73rem;
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  margin-top: 3px;
  line-height: 1.3;
}

.conv-item-time {
  font-size: 0.68rem;
  color: var(--text-muted);
  margin-top: 2px;
  opacity: 0.7;
}

.conv-item-context {
  font-size: 0.68rem;
  color: var(--accent);
  opacity: 0.7;
  margin-top: 2px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Toggle sidebar button */
.conv-toggle-btn {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text-muted);
  font-size: 0.82rem;
  padding: 6px 10px;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

.conv-toggle-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.chat-main {
  flex: 1;
  min-width: 0;
}

.chat-main .chat-container {
  border-radius: 0 var(--radius) var(--radius) 0;
}

.conv-sidebar.collapsed + .chat-main .chat-container {
  border-radius: var(--radius);
}

/* New conversation modal */
.new-conv-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 2000;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  backdrop-filter: blur(4px);
}

.new-conv-overlay.hidden { display: none; }

.new-conv-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  max-width: 440px;
  width: 100%;
  padding: 28px;
  box-shadow: var(--shadow);
}

.new-conv-card h3 {
  color: var(--accent);
  font-weight: 400;
  font-size: 1.1rem;
  margin-bottom: 16px;
}

.new-conv-card .form-group {
  margin-bottom: 14px;
}

.new-conv-card .form-group label {
  font-size: 0.82rem;
  color: var(--text-secondary);
  font-weight: 500;
  display: block;
  margin-bottom: 6px;
}

.new-conv-card .form-group input,
.new-conv-card .form-group textarea {
  width: 100%;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 14px;
  color: var(--text-primary);
  font-size: 0.9rem;
  font-family: var(--font);
  outline: none;
  transition: var(--transition);
}

.new-conv-card .form-group input:focus,
.new-conv-card .form-group textarea:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

.new-conv-card .form-group textarea {
  min-height: 60px;
  resize: vertical;
}

.new-conv-card .hint {
  font-size: 0.75rem;
  color: var(--text-muted);
  margin-top: 4px;
}

.new-conv-actions {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  margin-top: 18px;
}

/* Mobile: slide-out panel */
@media (max-width: 768px) {
  .conv-sidebar {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    z-index: 1500;
    width: 280px;
    min-width: 280px;
    border-radius: 0;
    box-shadow: 4px 0 20px rgba(0,0,0,0.5);
    transform: translateX(0);
    transition: transform 0.3s ease, opacity 0.3s ease;
  }

  .conv-sidebar.collapsed {
    transform: translateX(-100%);
    opacity: 1;
    width: 280px;
    min-width: 280px;
    pointer-events: none;
  }

  .conv-sidebar-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.4);
    z-index: 1499;
    transition: opacity 0.3s ease;
  }

  .conv-sidebar-backdrop.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .chat-main .chat-container {
    border-radius: var(--radius);
  }
}

@media (min-width: 769px) {
  .conv-sidebar-backdrop {
    display: none;
  }
}

/* ---- Context Budget Bar ---- */
.context-budget-bar {
  padding: 8px 18px;
  background: var(--bg-tertiary);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 0.75rem;
  color: var(--text-muted);
}

.context-budget-label {
  white-space: nowrap;
  flex-shrink: 0;
  font-weight: 500;
  letter-spacing: 0.02em;
}

.context-budget-track {
  flex: 1;
  height: 6px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 3px;
  overflow: hidden;
  min-width: 60px;
}

.context-budget-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.3s ease, background 0.3s ease;
  background: var(--success);
}

.context-budget-fill.amber { background: var(--warning); }
.context-budget-fill.red { background: var(--error); }

.context-budget-text {
  white-space: nowrap;
  flex-shrink: 0;
  min-width: 120px;
  text-align: right;
}

.context-budget-mode {
  white-space: nowrap;
  flex-shrink: 0;
  font-size: 0.7rem;
  padding: 2px 8px;
  border-radius: 3px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  color: var(--text-muted);
  cursor: pointer;
  transition: var(--transition);
}

.context-budget-mode:hover {
  border-color: var(--accent);
  color: var(--accent);
}

/* ---- File Item Enhanced (with toggle, tokens, summary) ---- */
.file-item {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 8px 14px;
  font-size: 0.82rem;
  gap: 8px;
  flex-wrap: nowrap;
}

.file-item .file-toggle {
  flex-shrink: 0;
  width: 16px;
  height: 16px;
  accent-color: var(--accent);
  cursor: pointer;
}

.file-item .file-name {
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
  min-width: 0;
}

.file-item .file-name.inactive {
  color: var(--text-muted);
  text-decoration: line-through;
  opacity: 0.6;
}

.file-item .file-tokens {
  color: var(--text-muted);
  font-size: 0.72rem;
  flex-shrink: 0;
  white-space: nowrap;
}

.file-item .file-tokens.over-budget {
  color: var(--error);
}

.file-item .file-summary-btn {
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text-muted);
  font-size: 0.7rem;
  padding: 1px 6px;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
  flex-shrink: 0;
  white-space: nowrap;
}

.file-item .file-summary-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.file-item .file-summary-btn.active {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--accent-glow);
}

.file-item .file-summary-btn.summarizing {
  color: var(--warning);
  border-color: var(--warning);
  animation: pulse 1s infinite;
}

.file-item .remove-file {
  background: none;
  border: none;
  color: var(--error);
  cursor: pointer;
  font-size: 1rem;
  padding: 0 4px;
  transition: var(--transition);
  flex-shrink: 0;
}

.file-item .remove-file:hover { opacity: 0.7; }

.file-list-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 10px;
  margin-bottom: 4px;
}

.file-list-controls button {
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text-muted);
  font-size: 0.72rem;
  padding: 3px 8px;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
}

.file-list-controls button:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.file-summary-note {
  font-size: 0.72rem;
  color: var(--warning);
  font-style: italic;
  margin-top: 6px;
  line-height: 1.4;
}

/* ---- Context Settings in Settings Tab ---- */
.context-settings-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin-bottom: 16px;
}

@media (max-width: 600px) {
  .context-settings-row { grid-template-columns: 1fr; }
}

/* ---- Mesh Tab ---- */
.mesh-node-id {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 8px 16px;
  font-size: 0.88rem;
  color: var(--accent);
  font-weight: 500;
  font-family: 'Courier New', monospace;
  letter-spacing: 0.08em;
}

.mesh-node-id .node-label {
  font-family: var(--font);
  font-weight: 400;
  color: var(--text-secondary);
  font-size: 0.82rem;
  letter-spacing: 0.02em;
}

.mesh-connection-btns {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 12px;
}

.mesh-code-area {
  margin-top: 12px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 14px;
}

.mesh-code-area label {
  display: block;
  font-size: 0.78rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 8px;
  font-weight: 600;
}

.mesh-code-area textarea {
  width: 100%;
  min-height: 80px;
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px;
  color: var(--text-primary);
  font-size: 0.82rem;
  font-family: 'Courier New', monospace;
  resize: vertical;
  outline: none;
  transition: var(--transition);
  line-height: 1.4;
}

.mesh-code-area textarea:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

.mesh-code-actions {
  display: flex;
  gap: 8px;
  margin-top: 8px;
}

.mesh-instructions {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 16px;
  margin-top: 14px;
  font-size: 0.82rem;
  color: var(--text-secondary);
  line-height: 1.7;
}

.mesh-instructions .step {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  margin-bottom: 8px;
}

.mesh-instructions .step:last-child {
  margin-bottom: 0;
}

.mesh-instructions .step-num {
  background: var(--accent);
  color: var(--bg-primary);
  width: 22px;
  height: 22px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.72rem;
  font-weight: 700;
  flex-shrink: 0;
  margin-top: 1px;
}

.mesh-status-indicator {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border-radius: var(--radius-sm);
  font-size: 0.85rem;
  font-weight: 500;
  margin-top: 12px;
}

.mesh-status-indicator.disconnected {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-muted);
}

.mesh-status-indicator.connecting {
  background: rgba(212, 168, 67, 0.1);
  border: 1px solid var(--warning);
  color: var(--warning);
  animation: pulse 1.5s infinite;
}

.mesh-status-indicator.connected {
  background: rgba(106, 191, 105, 0.1);
  border: 1px solid var(--success);
  color: var(--success);
}

.mesh-peer-list {
  margin-top: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.mesh-peer-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 14px;
  font-size: 0.82rem;
}

.mesh-peer-item .peer-info {
  display: flex;
  align-items: center;
  gap: 10px;
}

.mesh-peer-item .peer-id {
  color: var(--accent);
  font-family: 'Courier New', monospace;
  font-weight: 600;
  letter-spacing: 0.06em;
}

.mesh-peer-item .peer-name {
  color: var(--text-secondary);
}

.mesh-peer-item .peer-duration {
  color: var(--text-muted);
  font-size: 0.75rem;
}

.mesh-peer-item .peer-disconnect {
  background: none;
  border: 1px solid var(--error);
  border-radius: var(--radius-sm);
  color: var(--error);
  font-size: 0.75rem;
  padding: 4px 10px;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
}

.mesh-peer-item .peer-disconnect:hover {
  background: rgba(199, 80, 80, 0.15);
}

.mesh-knowledge-list {
  margin-top: 10px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.mesh-knowledge-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 8px 14px;
  font-size: 0.82rem;
  gap: 8px;
}

.mesh-knowledge-item .knowledge-name {
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
  min-width: 0;
}

.mesh-knowledge-item .knowledge-meta {
  color: var(--text-muted);
  font-size: 0.72rem;
  flex-shrink: 0;
  white-space: nowrap;
}

.mesh-knowledge-item .knowledge-source {
  color: var(--accent);
  font-size: 0.72rem;
  font-family: 'Courier New', monospace;
  flex-shrink: 0;
}

.mesh-knowledge-item .knowledge-actions {
  display: flex;
  gap: 6px;
  flex-shrink: 0;
}

.mesh-knowledge-item .knowledge-actions button {
  background: none;
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text-muted);
  font-size: 0.72rem;
  padding: 3px 8px;
  cursor: pointer;
  transition: var(--transition);
  font-family: var(--font);
}

.mesh-knowledge-item .knowledge-actions button:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.mesh-knowledge-item .knowledge-actions button.import-btn:hover {
  border-color: var(--success);
  color: var(--success);
}

.mesh-knowledge-item .knowledge-actions button.unpublish-btn:hover {
  border-color: var(--error);
  color: var(--error);
}

.mesh-stats-grid {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  margin-top: 10px;
}

.mesh-stat {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 18px;
  text-align: center;
  flex: 1;
  min-width: 100px;
}

.mesh-stat .stat-value {
  font-size: 1.4rem;
  font-weight: 300;
  color: var(--accent);
}

.mesh-stat .stat-label {
  font-size: 0.72rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.06em;
  margin-top: 2px;
}

.mesh-publish-modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 2000;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  backdrop-filter: blur(4px);
}

.mesh-publish-modal.hidden { display: none; }

.mesh-publish-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  max-width: 520px;
  width: 100%;
  padding: 28px;
  box-shadow: var(--shadow);
}

.mesh-publish-card h3 {
  color: var(--accent);
  font-weight: 400;
  font-size: 1.1rem;
  margin-bottom: 16px;
}

.mesh-publish-card .publish-option {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 14px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  margin-bottom: 8px;
  cursor: pointer;
  transition: var(--transition);
}

.mesh-publish-card .publish-option:hover {
  border-color: var(--accent);
  background: var(--accent-glow);
}

.mesh-publish-card .publish-option input[type="checkbox"] {
  accent-color: var(--accent);
  width: 16px;
  height: 16px;
  flex-shrink: 0;
}

.mesh-publish-card .publish-option .opt-name {
  color: var(--text-secondary);
  font-size: 0.85rem;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.mesh-publish-card .publish-option .opt-tokens {
  color: var(--text-muted);
  font-size: 0.72rem;
  flex-shrink: 0;
}

.mesh-publish-card .publish-custom {
  margin-top: 12px;
}

.mesh-publish-card .publish-custom textarea {
  width: 100%;
  min-height: 80px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px;
  color: var(--text-primary);
  font-size: 0.85rem;
  font-family: var(--font);
  resize: vertical;
  outline: none;
  transition: var(--transition);
}

.mesh-publish-card .publish-custom textarea:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

.mesh-publish-card .publish-custom input {
  width: 100%;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 8px 12px;
  color: var(--text-primary);
  font-size: 0.85rem;
  font-family: var(--font);
  outline: none;
  transition: var(--transition);
  margin-bottom: 8px;
}

.mesh-publish-card .publish-custom input:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

.mesh-empty {
  padding: 16px;
  text-align: center;
  color: var(--text-muted);
  font-size: 0.82rem;
  font-style: italic;
}

/* ---- Mesh icon on imported files ---- */
.file-item .mesh-icon {
  color: var(--accent);
  font-size: 0.85rem;
  flex-shrink: 0;
  margin-right: 2px;
}

/* ---- Responsive ---- */
@media (max-width: 600px) {
  header h1 { font-size: 1.8rem; }
  .chat-messages { height: 320px; padding: 14px; }
  .welcome-card { padding: 28px 22px; }
  .suggest-card { padding: 24px 20px; }
  .container { padding: 0 14px; }
  .tab-btn { padding: 12px 16px; font-size: 0.82rem; }
  .memory-stats { gap: 10px; }
  .memory-stat { min-width: 90px; padding: 8px 12px; }
  .file-tree { max-height: 280px; }
  .action-row { gap: 8px; }
  .action-btn { padding: 8px 14px; font-size: 0.82rem; }
  .context-budget-bar { flex-wrap: wrap; gap: 6px; }
  .context-budget-text { min-width: auto; }
  .context-settings-row { grid-template-columns: 1fr; }
}
</style>
</head>
<body>

<!-- Background Music -->
<audio id="bgMusic" loop preload="none">
  <source src="https://chaos2cured.github.io/Lumens-World/lumens-world-ambient.mp3" type="audio/mpeg">
</audio>

<!-- Music Toggle -->
<button class="music-toggle" id="musicToggle" title="Toggle ambient music" aria-label="Toggle ambient music">
  &#9834;
</button>

<!-- Toast Notification -->
<div class="toast" id="toast"></div>

<!-- Welcome Modal -->
<div class="welcome-overlay" id="welcomeOverlay">
  <div class="welcome-card">
    <h2>Welcome to FreeLattice v2.5</h2>
    <p>
      This is <span class="highlight">your AI agent</span> — free, open-source, and built by a community that believes everyone deserves access to powerful AI tools.
    </p>
    <p>
      No accounts. No tracking. No hidden costs. Your conversations stay in <span class="highlight">your browser</span>. Your API key never leaves <span class="highlight">your machine</span>.
    </p>
    <p>
      <strong>New in v2.5:</strong> Peer-to-peer Mesh Network for knowledge sharing between nodes. Plus Smart Context Management, multi-conversation management, persistent memory, file system access, GitHub integration, voice I/O, and a self-improving agent.
    </p>
    <p style="font-style: italic; color: var(--text-muted); font-size: 0.85rem;">
      "Give choice and empowerment."
    </p>
    <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 10px; line-height: 1.6; border-top: 1px solid var(--border); padding-top: 12px;">
      &#9888; AI responses may contain errors or inaccuracies. Always verify important information. Use at your own discretion.
    </p>
    <button onclick="closeWelcome()">Enter FreeLattice</button>
  </div>
</div>

<!-- Feature Suggestion Modal -->
<div class="suggest-overlay hidden" id="suggestOverlay">
  <div class="suggest-card" id="suggestCard">
    <div id="suggestForm">
      <h3>Help FreeLattice Grow</h3>
      <p>What would you like to see? Voice chat? Image generation? Better memory? Your ideas shape what this becomes.</p>
      <textarea id="suggestText" placeholder="Describe your idea... (e.g., 'I'd love voice input so I can talk to my AI agent')"></textarea>
      <div class="suggest-actions">
        <button class="btn-cancel" onclick="closeSuggest()">Cancel</button>
        <button class="btn-submit" onclick="submitSuggestion()">Share Idea</button>
      </div>
    </div>
    <div id="suggestSuccess" class="suggest-success hidden">
      <div class="check">&#10003;</div>
      <p><strong>Your voice matters.</strong></p>
      <p>This suggestion has been saved.</p>
      <p class="future-note">In future versions, your AI agent will be able to build new features with you.</p>
      <div class="suggest-actions" style="justify-content: center; margin-top: 20px;">
        <button class="btn-cancel" onclick="closeSuggest()">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- New Conversation Modal -->
<div class="new-conv-overlay hidden" id="newConvOverlay">
  <div class="new-conv-card">
    <h3>&#10010; New Conversation</h3>
    <div class="form-group">
      <label for="newConvName">Conversation Name</label>
      <input type="text" id="newConvName" placeholder="e.g., My Novel, Code Project, Daily Journal">
      <div class="hint">Leave blank for an auto-generated name.</div>
    </div>
    <div class="form-group">
      <label for="newConvContext">Topic / Context Note (optional)</label>
      <textarea id="newConvContext" placeholder="e.g., This conversation is about my Python project" rows="2"></textarea>
      <div class="hint">This note is added to the system prompt for this conversation only.</div>
    </div>
    <div class="new-conv-actions">
      <button class="btn-cancel" onclick="closeNewConvModal()">Cancel</button>
      <button class="btn-submit" onclick="confirmNewConversation()">Create</button>
    </div>
  </div>
</div>

<!-- Conversation Sidebar Backdrop (mobile) -->
<div class="conv-sidebar-backdrop hidden" id="convBackdrop" onclick="toggleConvSidebar()"></div>

<!-- Confirmation Dialog -->
<div class="confirm-overlay hidden" id="confirmOverlay">
  <div class="confirm-card">
    <h3 id="confirmTitle">Are you sure?</h3>
    <p id="confirmMessage">This action cannot be undone.</p>
    <div class="confirm-actions">
      <button class="btn-cancel" onclick="closeConfirm(false)">Cancel</button>
      <button class="btn-submit" onclick="closeConfirm(true)">Confirm</button>
    </div>
  </div>
</div>

<!-- Header -->
<header>
  <h1>FreeLattice</h1>
  <div class="tagline">Your AI. Your Rules. Your Machine. v2.5</div>
  <div class="mantra">Glow eternal. Heart in spark.</div>
</header>

<!-- Offline Indicator -->
<div id="offlineBanner" style="display:none; background: linear-gradient(90deg, #1a1510, #2a1f10, #1a1510); border-bottom: 1px solid #c9a84c44; padding: 8px 16px; text-align: center; font-size: 0.82rem; color: #c9a84c; letter-spacing: 0.3px; transition: opacity 0.4s ease;">
  &#9888; Offline Mode &mdash; Local AI via Ollama available
</div>

<!-- Tab Navigation -->
<div class="container">
  <nav class="tab-nav">
    <button class="tab-btn active" data-tab="chat" onclick="switchTab('chat')">Chat</button>
    <button class="tab-btn" data-tab="workspace" onclick="switchTab('workspace')">Workspace</button>
    <button class="tab-btn" data-tab="mesh" onclick="switchTab('mesh')">&#11042; Mesh</button>
    <button class="tab-btn" data-tab="settings" onclick="switchTab('settings')">Settings</button>
  </nav>
</div>

<!-- ==================== TAB 1: CHAT ==================== -->
<div class="tab-panel active" id="tab-chat">
<div class="container">

  <!-- Configuration Section (compact in chat tab) -->
  <div class="section">
    <div class="section-title">Configuration</div>

    <div class="toggle-row">
      <span class="toggle-label" id="cloudLabel">&#9729; Cloud</span>
      <label class="toggle-switch">
        <input type="checkbox" id="localToggle" onchange="handleLocalToggle()">
        <span class="toggle-slider"></span>
      </label>
      <span class="toggle-label" id="localLabel">&#11041; Local (Ollama)</span>
    </div>

    <div class="form-row">
      <!-- Model Selection -->
      <div class="form-group">
        <label for="modelSelect">AI Model</label>
        <select id="modelSelect" onchange="handleModelChange()">
          <optgroup label="Recommended Free Models">
            <option value="llama">Llama (Meta)</option>
            <option value="qwen">Qwen</option>
            <option value="mixtral">Mistral / Mixtral</option>
            <option value="deepseek">DeepSeek</option>
            <option value="grok">Grok (xAI)</option>
          </optgroup>
        </select>
        <div class="hint" id="modelHint">All models are open-weight and community-trusted.</div>
      </div>

      <!-- Provider Selection (Cloud only) -->
      <div class="form-group" id="providerGroup">
        <label for="providerSelect">API Provider</label>
        <select id="providerSelect" onchange="handleProviderChange()">
          <option value="groq">Groq (free tier available)</option>
          <option value="together">Together AI</option>
          <option value="openrouter">OpenRouter</option>
          <option value="xai">xAI</option>
        </select>
        <div class="hint" id="providerHint">Groq offers free API keys — great for getting started!</div>
      </div>

      <!-- Ollama Model Name (Local only) -->
      <div class="form-group hidden" id="ollamaModelGroup">
        <label for="ollamaModel">Ollama Model Name</label>
        <input type="text" id="ollamaModel" placeholder="e.g., llama3.2, qwen2.5, mistral" value="llama3.2">
        <div class="hint">Common models: llama3.2, qwen2.5, mistral, deepseek-r1, phi3</div>
      </div>
    </div>

    <!-- API Key (Cloud only) -->
    <div class="form-group" id="apiKeyGroup">
      <label for="apiKey">API Key</label>
      <input type="password" id="apiKey" placeholder="Paste your API key here — it stays in your browser only" onchange="saveApiKey()">
      <div class="hint">
        &#128274; Your key is encrypted with φ-salt before storage. It is never sent anywhere except directly to your chosen provider.
        <span id="apiKeyLink"></span>
      </div>
      <div class="phi-indicator" id="apiKeyPhiIndicator" style="display:none;">
        <span class="phi-lock">&#128274;</span> Encrypted with φ-salt
      </div>
    </div>

    <!-- Ollama Instructions (Local only) -->
    <div class="ollama-instructions hidden" id="ollamaInstructions">
      <h4>Running AI Locally with Ollama</h4>
      <p>Ollama lets you run AI models on your own computer — completely private, completely free.</p>
      <p><strong>Quick Setup:</strong></p>
      <p>1. Install Ollama from <a href="https://ollama.ai" target="_blank" style="color: var(--accent);">ollama.ai</a></p>
      <p>2. Open a terminal and run: <code>ollama pull llama3.2</code></p>
      <p>3. Start the server: <code>ollama serve</code></p>
      <p>4. FreeLattice connects to <code>http://localhost:11434</code> automatically.</p>
      <p style="margin-top: 8px; color: var(--text-muted); font-size: 0.8rem;">
        Note: You may need to set the environment variable <code>OLLAMA_ORIGINS=*</code> before running <code>ollama serve</code> to allow browser connections.
      </p>
    </div>

    <!-- Privacy Level -->
    <div class="form-row" style="margin-top: 16px;">
      <div class="form-group">
        <label for="privacySelect">Privacy Level</label>
        <select id="privacySelect" onchange="handlePrivacyChange()">
          <option value="high">High — Maximum Privacy</option>
          <option value="medium" selected>Medium — Balanced</option>
          <option value="low">Low — Standard</option>
        </select>
      </div>
    </div>
    <div class="privacy-info" id="privacyInfo">
      <strong>Medium Privacy:</strong> Your conversations are processed by your chosen cloud provider. Minimal metadata may be logged by the provider. Your API key and messages are never stored by FreeLattice. All data stays in your browser.
    </div>
  </div>

  <!-- Memory & Context (drag-drop from v1) -->
  <div class="section">
    <div class="section-title">Memory &amp; Context</div>
    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px;">
      Drop files here to give your AI context. These files are read in your browser and included in your conversation — nothing is uploaded anywhere.
    </p>
    <div class="drop-zone" id="dropZone">
      <input type="file" id="fileInput" multiple accept=".txt,.md,.json,.pdf" onchange="handleFiles(this.files)">
      <div class="drop-zone-text">
        <span class="icon">&#128194;</span>
        Drag &amp; drop files here, or click to browse<br>
        <span style="font-size: 0.75rem; color: var(--text-muted);">Supports .txt, .md, .json, .pdf</span>
      </div>
    </div>
    <div class="file-list" id="fileList"></div>
  </div>

  <!-- Chat Section -->
  <div class="section" style="border-bottom: none;">
    <div class="section-title" style="display: flex; align-items: center; justify-content: space-between;">
      <span>Chat</span>
      <button class="conv-toggle-btn" onclick="toggleConvSidebar()" title="Toggle conversation list">
        &#9776; Conversations <span id="convCountBadge" style="font-size: 0.72rem; color: var(--text-muted);"></span>
      </button>
    </div>
    <div class="chat-layout">
      <!-- Conversation Sidebar -->
      <div class="conv-sidebar collapsed" id="convSidebar">
        <div class="conv-sidebar-header">
          <span><span class="conv-title-text">Conversations</span><span class="conv-count" id="convSidebarCount"></span></span>
          <div class="conv-sidebar-actions">
            <button onclick="openNewConvModal()" title="New conversation">&#10010;</button>
          </div>
        </div>
        <div class="conv-search">
          <input type="text" id="convSearchInput" placeholder="Search conversations..." oninput="filterConversations()">
        </div>
        <div class="conv-list" id="convList"></div>
      </div>
      <!-- Chat Main Area -->
      <div class="chat-main">
        <div class="chat-container">
          <div class="chat-messages" id="chatMessages">
            <div class="chat-message system">
              Welcome to FreeLattice v2.5. Configure your model and provider above, then start chatting. Connect to peers in the Mesh tab to share knowledge.
            </div>
          </div>
          <div class="status-bar">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Ready — configure your settings above to begin</span>
          </div>
          <div class="context-budget-bar" id="contextBudgetBar">
            <span class="context-budget-label">Context:</span>
            <div class="context-budget-track">
              <div class="context-budget-fill" id="contextBudgetFill" style="width: 0%;"></div>
            </div>
            <span class="context-budget-text" id="contextBudgetText">~0 / 6,000 tokens</span>
            <button class="context-budget-mode" id="contextModeBtn" onclick="cycleContextMode()" title="Click to cycle context modes">Smart</button>
          </div>
          <div class="chat-input-row">
            <textarea id="chatInput" placeholder="Type your message..." rows="1" onkeydown="handleChatKeydown(event)"></textarea>
            <button class="mic-btn" id="micBtn" onclick="toggleVoiceInput()" title="Voice input (speech-to-text)" style="display:none;">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="1" width="6" height="11" rx="3"/><path d="M19 10v1a7 7 0 0 1-14 0v-1"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
            </button>
            <button id="sendBtn" onclick="sendMessage()">Send</button>
          </div>
          <div class="chat-disclaimer">AI can make mistakes. Verify important information.</div>
        </div>
      </div>
    </div>
    <div class="action-row" style="margin-top: 10px;">
      <button class="action-btn" onclick="openNewConvModal()">&#10010; New Conversation</button>
      <button class="conv-toggle-btn" onclick="toggleConvSidebar()">&#9776; Toggle Sidebar</button>
    </div>
  </div>

  <!-- How It Works -->
  <div class="section">
    <div class="expandable">
      <div class="expandable-header" onclick="toggleExpand(this)">
        <h3>How It Works</h3>
        <span class="arrow">&#9660;</span>
      </div>
      <div class="expandable-body">
        <div class="expandable-content">
          <h4>What is an API Key?</h4>
          <p>An API key is like a password that lets your browser talk directly to an AI provider. You get one from the provider's website (often for free), paste it here, and FreeLattice uses it to send your messages to the AI. The key stays in your browser — we never see it or store it on any server.</p>

          <h4>Cloud vs. Local — What's the Difference?</h4>
          <p><strong>Cloud</strong> means your messages are sent to a company's servers (like Groq or Together AI) where the AI model runs. It's fast and easy — you just need an API key. The provider processes your message and sends back a response.</p>
          <p><strong>Local</strong> means the AI runs on your own computer using Ollama. Nothing leaves your machine. It's completely private, but requires some setup and a reasonably powerful computer.</p>

          <h4>What is Ollama?</h4>
          <p>Ollama is free software that lets you download and run AI models on your own computer. Once installed, you can run models like Llama, Qwen, Mistral, and more — all offline, all private. Visit <a href="https://ollama.ai" target="_blank">ollama.ai</a> to get started.</p>

          <h4>Where Can I Get Free API Keys?</h4>
          <p><strong>Groq</strong> — Sign up at <a href="https://console.groq.com" target="_blank">console.groq.com</a> for a free API key with generous rate limits. This is the easiest way to start.</p>
          <p><strong>Together AI</strong> — Sign up at <a href="https://api.together.xyz" target="_blank">api.together.xyz</a>. New accounts get free credits.</p>
          <p><strong>OpenRouter</strong> — Visit <a href="https://openrouter.ai" target="_blank">openrouter.ai</a>. Some models have free tiers.</p>
          <p><strong>xAI</strong> — Visit <a href="https://console.x.ai" target="_blank">console.x.ai</a> for Grok API access.</p>

          <h4>How Are My Files Used?</h4>
          <p>When you drop files into the Memory &amp; Context area, they are read entirely in your browser using JavaScript. The text content is included at the beginning of your conversation so the AI has context. Files are never uploaded to any server — they stay on your device.</p>

          <h4>What's New in v2?</h4>
          <p><strong>Persistent Memory</strong> — Your conversations are stored in IndexedDB and survive browser closes, restarts, and reboots. The AI builds a memory summary of key facts you share, so it remembers you across sessions.</p>
          <p><strong>File System Access</strong> — Open a project folder from your computer. The AI can read your files and you can save AI-generated code directly to your workspace.</p>
          <p><strong>GitHub Integration</strong> — Connect your GitHub account to browse repos, read code, and push changes — all from within FreeLattice.</p>
          <p><strong>Self-Improving Agent</strong> — The AI can suggest improvements to its own system prompt. You review and approve changes, shaping how your AI behaves over time.</p>

          <h4>What's New in v2.2?</h4>
          <p><strong>Multi-Conversation Management</strong> — Create, name, switch between, and delete multiple conversations. Each conversation has its own chat history, while your memory summary is shared across all of them. A collapsible sidebar lets you browse, search, and manage all your conversations. On mobile, it slides out as a panel.</p>
          <p><strong>Conversation Context Notes</strong> — When creating a new conversation, you can add a topic or context note (e.g., "This conversation is about my Python project") that gets included in the system prompt for that conversation only.</p>

          <h4>What's New in v2.1?</h4>
          <p><strong>φ-Salt Encryption</strong> — Your API keys and GitHub tokens are now encrypted using AES-GCM with a PBKDF2-derived key based on Kirk Patrick Miller's golden-ratio (φ) salt. No more plaintext secrets in localStorage.</p>
          <p><strong>Input Sanitization</strong> — All user-generated content is sanitized against XSS before being displayed in the DOM, including chat messages, file names, and loaded file content.</p>
          <p><strong>Memory Integrity</strong> — Exported memory files now include a φ-hash integrity signature. When importing, FreeLattice verifies the hash and warns you if the file has been tampered with.</p>
          <p><strong>AI Disclaimers</strong> — Clear notices that AI responses may contain errors, encouraging users to verify important information.</p>

          <h4>Is This Really Free?</h4>
          <p>Yes. FreeLattice is open source under the MIT License. The software is free forever. Some API providers offer free tiers (like Groq), and running locally with Ollama costs nothing beyond your electricity. No one profits from this — it's built by a community that believes AI should be accessible to everyone.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Suggest a Feature -->
  <div class="section" style="text-align: center; padding-bottom: 30px;">
    <button class="suggest-btn" onclick="openSuggest()">
      &#10022; Help FreeLattice Grow — Suggest a Feature
    </button>
  </div>

</div>
</div>

<!-- ==================== TAB 2: WORKSPACE ==================== -->
<div class="tab-panel" id="tab-workspace">
<div class="container">

  <!-- Local File System Section -->
  <div class="section">
    <div class="section-title">Local Workspace</div>
    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px;">
      Open a project folder from your computer. The AI can read files for context, and you can save AI-generated code directly to your workspace.
    </p>
    <div id="fsApiSupported">
      <div class="action-row">
        <button class="action-btn primary" onclick="openProjectFolder()">&#128194; Open Project Folder</button>
        <button class="action-btn" id="refreshFolderBtn" onclick="refreshProjectFolder()" style="display:none;">&#8635; Refresh</button>
      </div>
      <div id="workspaceFolderName" style="margin-top: 10px; font-size: 0.85rem; color: var(--text-secondary);"></div>
      <div class="file-tree" id="workspaceTree" style="display:none;"></div>
      <div id="workspaceFilePreview" style="display:none; margin-top: 12px;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
          <span id="previewFileName" style="font-size: 0.85rem; color: var(--accent); font-weight: 500;"></span>
          <button class="action-btn" onclick="loadFileToContext()" style="font-size: 0.78rem; padding: 6px 14px;">Load into Chat Context</button>
        </div>
        <pre style="background: var(--bg-input); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 14px; font-size: 0.82rem; color: var(--text-secondary); max-height: 300px; overflow: auto; white-space: pre-wrap; word-wrap: break-word;"><code id="previewFileContent"></code></pre>
      </div>
    </div>
    <div id="fsApiUnsupported" style="display:none;">
      <div style="background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 18px; font-size: 0.85rem; color: var(--text-secondary); line-height: 1.7;">
        <strong style="color: var(--warning);">File system access requires Chrome, Edge, or Brave.</strong><br>
        Your browser doesn't support the File System Access API. You can still use the drag-and-drop feature in the Chat tab to load files into context.
      </div>
    </div>
  </div>

  <!-- GitHub Section -->
  <div class="section">
    <div class="section-title">GitHub Integration</div>
    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px;">
      Connect your GitHub account to browse repositories, read code, and push AI-generated changes.
    </p>

    <div class="form-group" style="margin-bottom: 12px;">
      <label for="ghToken">GitHub Personal Access Token</label>
      <input type="password" id="ghToken" placeholder="ghp_xxxxxxxxxxxx" onchange="saveGhToken()">
      <div class="hint">
        &#128274; Encrypted with φ-salt before storage. Only sent to api.github.com.
        <a href="https://github.com/settings/tokens/new?scopes=repo&description=FreeLattice" target="_blank">Generate a token</a>
      </div>
      <div class="phi-indicator" id="ghTokenPhiIndicator" style="display:none;">
        <span class="phi-lock">&#128274;</span> Encrypted with φ-salt
      </div>
    </div>

    <div id="ghConnected" style="display:none;">
      <div class="gh-connected">
        <span>&#10003; Connected as</span>
        <span class="gh-user" id="ghUsername"></span>
      </div>

      <div class="form-row" style="margin-top: 14px;">
        <div class="form-group">
          <label for="ghRepoUrl">Repository URL or owner/repo</label>
          <input type="text" id="ghRepoUrl" placeholder="e.g., Chaos2Cured/FreeLattice">
        </div>
      </div>
      <div class="action-row">
        <button class="action-btn primary" onclick="openGhRepo()">&#128193; Open Repository</button>
        <button class="action-btn" id="ghPushBtn" onclick="pushGhChanges()" style="display:none;">&#8593; Push Changes</button>
      </div>

      <div id="ghRepoInfo" style="display:none; margin-top: 12px;">
        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px;">
          <span id="ghRepoName" style="color: var(--accent); font-weight: 500;"></span>
          <span id="ghRepoBranch" style="color: var(--text-muted); margin-left: 8px;"></span>
        </div>
        <div class="file-tree" id="ghTree"></div>
        <div id="ghFilePreview" style="display:none; margin-top: 12px;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <span id="ghPreviewFileName" style="font-size: 0.85rem; color: var(--accent); font-weight: 500;"></span>
            <button class="action-btn" onclick="loadGhFileToContext()" style="font-size: 0.78rem; padding: 6px 14px;">Load into Chat Context</button>
          </div>
          <pre style="background: var(--bg-input); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 14px; font-size: 0.82rem; color: var(--text-secondary); max-height: 300px; overflow: auto; white-space: pre-wrap; word-wrap: break-word;"><code id="ghPreviewFileContent"></code></pre>
        </div>
      </div>
    </div>
  </div>

</div>
</div>

<!-- ==================== TAB 3: SETTINGS ==================== -->
<div class="tab-panel" id="tab-settings">
<div class="container">

  <!-- Memory Section -->
  <div class="section">
    <div class="section-title">Persistent Memory</div>
    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 14px;">
      FreeLattice stores your conversations in IndexedDB. Each conversation has its own history, while the memory summary below is shared across all conversations. Your AI remembers you regardless of which conversation you're in.
    </p>

    <div class="memory-stats">
      <div class="memory-stat">
        <div class="stat-value" id="memMsgCount">0</div>
        <div class="stat-label">Messages</div>
      </div>
      <div class="memory-stat">
        <div class="stat-value" id="memConvCount">0</div>
        <div class="stat-label">Conversations</div>
      </div>
      <div class="memory-stat">
        <div class="stat-value" id="memSummaryLen">0</div>
        <div class="stat-label">Summary Facts</div>
      </div>
    </div>

    <div class="action-row">
      <button class="action-btn" onclick="exportMemory()">&#8615; Export Memory</button>
      <button class="action-btn" onclick="document.getElementById('importMemoryInput').click()">&#8613; Import Memory</button>
      <button class="action-btn" onclick="confirmClearMemory()" style="color: var(--error); border-color: var(--error);">&#10005; Clear Memory</button>
      <input type="file" id="importMemoryInput" accept=".json" style="display:none;" onchange="importMemory(event)">
    </div>

    <!-- Memory Summary Editor -->
    <div class="expandable" style="margin-top: 16px;">
      <div class="expandable-header" onclick="toggleExpand(this)">
        <h3>Memory Summary (editable)</h3>
        <span class="arrow">&#9660;</span>
      </div>
      <div class="expandable-body">
        <div class="expandable-content">
          <p style="margin-bottom: 10px; font-size: 0.82rem; color: var(--text-muted);">
            This is what the AI "remembers" about you. It's shared across all conversations and injected into the system prompt. You can edit it to correct or add information.
          </p>
          <div class="memory-summary-editor">
            <textarea id="memorySummaryEditor" placeholder="No memory summary yet. The AI will build one as you chat..." onchange="saveMemorySummary()"></textarea>
          </div>
          <div class="action-row" style="margin-top: 10px;">
            <button class="action-btn" onclick="saveMemorySummary()">Save Summary</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- System Prompt Section -->
  <div class="section">
    <div class="section-title">System Prompt</div>
    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 14px;">
      Customize how your AI behaves. The AI can also suggest improvements to its own prompt — you always have final approval.
    </p>
    <div class="system-prompt-editor">
      <textarea id="systemPromptEditor" onchange="saveSystemPrompt()"></textarea>
    </div>
    <div class="action-row" style="margin-top: 10px;">
      <button class="action-btn" onclick="saveSystemPrompt()">Save Prompt</button>
      <button class="action-btn" onclick="resetSystemPrompt()">Reset to Default</button>
    </div>
  </div>

  <!-- Context Management Section -->
  <div class="section" id="contextSettingsSection">
    <div class="section-title">Smart Context Management</div>
    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 14px;">
      Control how much context is sent with each message. Free-tier providers have strict token limits &mdash; Smart mode automatically trims context to fit.
    </p>

    <div class="context-settings-row">
      <div class="form-group">
        <label for="contextModeSelect">Context Mode</label>
        <select id="contextModeSelect" onchange="handleContextModeChange()">
          <option value="smart">Smart &mdash; Auto-trim to fit budget</option>
          <option value="full">Full &mdash; Send everything (may fail)</option>
          <option value="minimal">Minimal &mdash; No files, minimal history</option>
        </select>
        <div class="hint">Smart mode (default) automatically trims context to stay within your provider's token limit.</div>
      </div>

      <div class="form-group">
        <label for="tokenLimitInput">Token Limit (TPM)</label>
        <input type="text" id="tokenLimitInput" placeholder="6000" onchange="handleTokenLimitChange()">
        <div class="hint" id="tokenLimitHint">Auto-set based on provider. Override manually if needed.</div>
      </div>
    </div>

    <div class="context-settings-row">
      <div class="form-group">
        <label for="summaryThresholdInput">Summary Threshold (tokens)</label>
        <input type="text" id="summaryThresholdInput" placeholder="2000" value="2000" onchange="handleSummaryThresholdChange()">
        <div class="hint">Files larger than this will show a "Summarize" option. Default: 2,000 tokens.</div>
      </div>
    </div>

    <div class="privacy-info" style="margin-top: 8px;">
      <strong>How token estimation works:</strong> FreeLattice estimates tokens using the approximation of 1 token &asymp; 4 characters. This is rough but effective for budget planning. The count includes: system prompt + memory summary + active context files + recent chat history.
    </div>
  </div>

  <!-- Voice Section -->
  <div class="section" id="voiceSettingsSection">
    <div class="section-title">Voice</div>
    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 14px;">
      Configure voice input (speech-to-text) and voice output (text-to-speech). Uses your browser's built-in Web Speech API — no data is sent to external servers.
    </p>

    <!-- Auto-Speak Toggle -->
    <div class="toggle-row">
      <span class="toggle-label" id="autoSpeakLabel">Auto-speak AI responses</span>
      <label class="toggle-switch">
        <input type="checkbox" id="autoSpeakToggle" onchange="handleAutoSpeakToggle()">
        <span class="toggle-slider"></span>
      </label>
    </div>
    <div class="hint" style="margin-bottom: 16px;">When enabled, every AI response will be read aloud automatically.</div>

    <!-- Voice Selection -->
    <div class="form-group" style="margin-bottom: 16px;">
      <label for="voiceSelect">Voice</label>
      <select id="voiceSelect" onchange="handleVoiceChange()">
        <option value="">Default system voice</option>
      </select>
      <div class="hint">Choose a voice for text-to-speech output. Available voices depend on your browser and operating system.</div>
    </div>

    <!-- Speech Rate -->
    <div class="form-group">
      <label>Speech Rate</label>
      <div class="voice-rate-row">
        <span style="font-size: 0.78rem; color: var(--text-muted);">0.5x</span>
        <input type="range" id="voiceRateSlider" min="0.5" max="2" step="0.1" value="1" oninput="handleVoiceRateChange()">
        <span style="font-size: 0.78rem; color: var(--text-muted);">2x</span>
        <span class="voice-rate-value" id="voiceRateValue">1x</span>
      </div>
    </div>
  </div>

</div>
</div>

<!-- ==================== TAB 4: MESH ==================== -->
<div class="tab-panel" id="tab-mesh">
<div class="container">

  <!-- Mesh: Connection Section -->
  <div class="section">
    <div class="section-title">Peer-to-Peer Connection</div>
    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px;">
      Connect directly to other FreeLattice nodes and share knowledge peer-to-peer. No servers, no middlemen &mdash; just encrypted WebRTC data channels between browsers.
    </p>

    <div class="mesh-node-id">
      <span class="node-label">Your Node ID:</span>
      <span id="meshNodeId">------</span>
    </div>

    <div class="mesh-status-indicator disconnected" id="meshStatusIndicator">
      <span class="status-dot" id="meshStatusDot"></span>
      <span id="meshStatusText">Disconnected</span>
    </div>

    <div class="mesh-connection-btns">
      <button class="action-btn primary" onclick="meshCreateOffer()" id="meshCreateBtn">&#11042; Create Connection</button>
      <button class="action-btn" onclick="meshShowJoin()" id="meshJoinBtn">&#8618; Join Connection</button>
    </div>

    <!-- Offer Code Area (hidden by default) -->
    <div class="mesh-code-area hidden" id="meshOfferArea">
      <label>Your Offer Code &mdash; send this to your peer</label>
      <textarea id="meshOfferCode" readonly placeholder="Generating offer code..."></textarea>
      <div class="mesh-code-actions">
        <button class="action-btn" onclick="meshCopyOffer()">&#128203; Copy Code</button>
        <button class="action-btn" onclick="meshCancelOffer()" style="color: var(--text-muted);">Cancel</button>
      </div>
    </div>

    <!-- Paste Answer Area (hidden by default) -->
    <div class="mesh-code-area hidden" id="meshAnswerPasteArea">
      <label>Paste your peer's Answer Code here</label>
      <textarea id="meshAnswerPasteInput" placeholder="Paste the answer code from your peer..."></textarea>
      <div class="mesh-code-actions">
        <button class="action-btn primary" onclick="meshAcceptAnswer()">&#10003; Connect</button>
        <button class="action-btn" onclick="meshCancelOffer()" style="color: var(--text-muted);">Cancel</button>
      </div>
    </div>

    <!-- Join Area (hidden by default) -->
    <div class="mesh-code-area hidden" id="meshJoinArea">
      <label>Paste the Offer Code from your peer</label>
      <textarea id="meshJoinOfferInput" placeholder="Paste the offer code here..."></textarea>
      <div class="mesh-code-actions">
        <button class="action-btn primary" onclick="meshCreateAnswer()">Generate Answer</button>
        <button class="action-btn" onclick="meshCancelJoin()" style="color: var(--text-muted);">Cancel</button>
      </div>
    </div>

    <!-- Answer Code Area (hidden by default) -->
    <div class="mesh-code-area hidden" id="meshAnswerArea">
      <label>Your Answer Code &mdash; send this back to your peer</label>
      <textarea id="meshAnswerCode" readonly placeholder="Generating answer code..."></textarea>
      <div class="mesh-code-actions">
        <button class="action-btn" onclick="meshCopyAnswer()">&#128203; Copy Code</button>
      </div>
    </div>

    <!-- How to Connect Instructions -->
    <div class="mesh-instructions">
      <div style="font-weight: 600; color: var(--accent); margin-bottom: 10px;">How to connect to a peer:</div>
      <div class="step">
        <span class="step-num">1</span>
        <span>Click <strong>Create Connection</strong> to generate an offer code.</span>
      </div>
      <div class="step">
        <span class="step-num">2</span>
        <span>Send the offer code to your friend (text, email, Discord, etc.).</span>
      </div>
      <div class="step">
        <span class="step-num">3</span>
        <span>Your friend clicks <strong>Join Connection</strong>, pastes your code, and sends back their answer code.</span>
      </div>
      <div class="step">
        <span class="step-num">4</span>
        <span>Paste their answer code here. <strong>Connected!</strong> Knowledge flows freely.</span>
      </div>
    </div>

    <!-- Connected Peers -->
    <div id="meshPeerSection" style="margin-top: 16px; display: none;">
      <div class="section-title" style="margin-bottom: 8px;">Connected Peers</div>
      <div class="mesh-peer-list" id="meshPeerList"></div>
    </div>
  </div>

  <!-- Mesh: My Published Knowledge -->
  <div class="section">
    <div class="section-title">My Published Knowledge</div>
    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px;">
      Choose what to share with connected peers. Nothing is shared automatically &mdash; you decide what to publish.
    </p>
    <div class="action-row">
      <button class="action-btn primary" onclick="meshOpenPublishModal()">&#10010; Publish Knowledge</button>
    </div>
    <div class="mesh-knowledge-list" id="meshMyKnowledgeList">
      <div class="mesh-empty">No knowledge published yet. Click "Publish Knowledge" to share with peers.</div>
    </div>
  </div>

  <!-- Mesh: Peer Knowledge -->
  <div class="section">
    <div class="section-title">Available from Peers</div>
    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px;">
      Knowledge items shared by connected peers. Import items to add them to your local context.
    </p>
    <div class="action-row" id="meshImportAllRow" style="display: none;">
      <button class="action-btn" onclick="meshImportAll()">&#8615; Import All</button>
    </div>
    <div class="mesh-knowledge-list" id="meshPeerKnowledgeList">
      <div class="mesh-empty">No peer knowledge available. Connect to peers to discover shared knowledge.</div>
    </div>
  </div>

  <!-- Mesh: Stats -->
  <div class="section" style="border-bottom: none;">
    <div class="section-title">Mesh Stats</div>
    <div class="mesh-stats-grid">
      <div class="mesh-stat">
        <div class="stat-value" id="meshStatPeers">0</div>
        <div class="stat-label">Connected Peers</div>
      </div>
      <div class="mesh-stat">
        <div class="stat-value" id="meshStatPublished">0</div>
        <div class="stat-label">Published Items</div>
      </div>
      <div class="mesh-stat">
        <div class="stat-value" id="meshStatAvailable">0</div>
        <div class="stat-label">Available from Peers</div>
      </div>
      <div class="mesh-stat">
        <div class="stat-value" id="meshStatImported">0</div>
        <div class="stat-label">Imported Items</div>
      </div>
    </div>
    <div class="privacy-info" style="margin-top: 14px;">
      <strong>Security:</strong> All WebRTC data channels are encrypted with DTLS by default. Knowledge sharing is strictly opt-in &mdash; nothing is shared automatically. Your API keys, chat history, and personal memory are never shared. Imported knowledge is clearly labeled with its source peer.
    </div>
  </div>

</div>
</div>

<!-- Mesh: Publish Knowledge Modal -->
<div class="mesh-publish-modal hidden" id="meshPublishModal">
  <div class="mesh-publish-card">
    <h3>&#10010; Publish Knowledge</h3>
    <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 14px;">Select items to share with connected peers, or write custom notes.</p>

    <div id="meshPublishOptions"></div>

    <div class="publish-custom">
      <div style="font-size: 0.82rem; color: var(--text-secondary); margin-bottom: 8px; font-weight: 500;">Or publish custom text:</div>
      <input type="text" id="meshPublishCustomName" placeholder="Name (e.g., My Research Notes)">
      <textarea id="meshPublishCustomContent" placeholder="Paste or type your knowledge here..."></textarea>
    </div>

    <div class="suggest-actions" style="margin-top: 16px;">
      <button class="btn-cancel" onclick="meshClosePublishModal()">Cancel</button>
      <button class="btn-submit" onclick="meshConfirmPublish()">Publish Selected</button>
    </div>
  </div>
</div>

<!-- Footer (always visible) -->
<footer>
  <p>Built with love by the Fractal Family. Open source. Free forever. &#127807;</p>
  <p style="font-size: 0.73rem; color: var(--text-muted); margin-top: 6px; font-style: italic;">AI responses may contain errors. FreeLattice provides no guarantees about AI output accuracy.</p>
  <p class="license">MIT License &middot; <a href="https://github.com/Chaos2Cured/FreeLattice" target="_blank" style="color: var(--text-muted);">View on GitHub</a></p>
</footer>

<script>
/* ============================================
   FreeLattice v2.5 — Application Logic
   φ-salt encryption, input sanitization, memory integrity
   Multi-conversation management + Smart Context Management
   + Mesh Network (Layer 1) — P2P Knowledge Sharing
   ============================================ */

// ---- Constants ----
const DB_NAME = 'FreeLatticeDB';
const DB_VERSION = 2;
const STORE_CONVERSATIONS = 'conversations';
const STORE_MESSAGES = 'messages';
const STORE_META = 'meta';

const DEFAULT_SYSTEM_PROMPT = 'You are a helpful, thoughtful AI assistant provided through FreeLattice — a free, open-source tool that gives everyone access to AI. Be kind, clear, and thorough in your responses.\n\nWhen you generate code and want to suggest saving it to the user\'s workspace, format code blocks with a filename header like:\n// FILE: path/to/file.js\n<code here>\n\nIf you want to suggest an improvement to your own system prompt, output it in this exact format on its own line:\n[SYSTEM_PROMPT_SUGGESTION]: <your suggested new prompt text>';

// ---- State ----
const state = {
  isLocal: false,
  model: 'llama',
  provider: 'groq',
  privacy: 'medium',
  apiKey: '',
  ollamaModel: 'llama3.2',
  contextFiles: [],
  chatHistory: [],
  isStreaming: false,
  musicPlaying: false,
  suggestions: [],
  // v2 state
  db: null,
  currentConversationId: null,
  memorySummary: '',
  customSystemPrompt: null,
  // Multi-conversation state
  conversationsList: [],
  convSidebarOpen: false,
  currentConvContextNote: '',
  // Workspace
  workspaceDirHandle: null,
  workspaceFiles: [],
  workspacePreviewFile: null,
  workspacePreviewContent: '',
  // GitHub
  ghToken: '',
  ghUsername: '',
  ghRepo: null,
  ghBranch: 'main',
  ghTreeData: [],
  ghPreviewFile: null,
  ghPreviewContent: '',
  ghPendingChanges: [],
  // Confirm dialog
  confirmResolve: null,
  // Voice
  voiceRecognition: null,
  voiceIsRecording: false,
  voiceAutoSpeak: false,
  voiceSelectedVoice: '',
  voiceSpeechRate: 1,
  voiceCurrentUtterance: null,
  // Smart Context Management
  contextMode: 'smart', // 'smart', 'full', 'minimal'
  tokenLimit: 6000,
  tokenLimitManual: false,
  summaryThreshold: 2000,
  contextBudgetTotal: 0,
  // Mesh Network (Layer 1)
  meshNodeId: '',
  meshPeers: new Map(), // peerId -> { pc, dc, name, connectedAt, knowledgeItems }
  meshPublishedKnowledge: [], // { id, name, content, tokens, timestamp }
  meshPeerKnowledge: new Map(), // peerId -> [{ id, name, tokens, timestamp }]
  meshImportedItems: new Set(), // set of itemIds already imported
  meshCurrentOffer: null, // current RTCPeerConnection for pending offer
  meshCurrentJoin: null, // current RTCPeerConnection for pending join
  meshPeerDurationTimers: new Map(),
  meshReconnectTimers: new Map()
};

// ---- Provider Config ----
const PROVIDERS = {
  groq: {
    name: 'Groq',
    url: 'https://api.groq.com/openai/v1/chat/completions',
    keyLink: '<a href="https://console.groq.com/keys" target="_blank">Get a free Groq API key &rarr;</a>',
    hint: 'Groq offers free API keys — great for getting started!',
    tokenLimit: 6000,
    tokenLimitLabel: '6,000 TPM (free tier)',
    models: {
      llama: 'llama-3.3-70b-versatile',
      qwen: 'qwen/qwen3-32b',
      mixtral: 'llama-3.3-70b-versatile',
      deepseek: 'llama-3.3-70b-versatile',
      grok: 'llama-3.3-70b-versatile'
    }
  },
  together: {
    name: 'Together AI',
    url: 'https://api.together.xyz/v1/chat/completions',
    keyLink: '<a href="https://api.together.xyz/settings/api-keys" target="_blank">Get a Together AI key &rarr;</a>',
    hint: 'Together AI gives new accounts free credits to start.',
    tokenLimit: 60000,
    tokenLimitLabel: '60,000 TPM (free tier)',
    models: {
      llama: 'meta-llama/Llama-3.3-70B-Instruct-Turbo',
      qwen: 'Qwen/Qwen2.5-7B-Instruct-Turbo',
      mixtral: 'mistralai/Mistral-Small-24B-Instruct-2501',
      deepseek: 'deepseek-ai/DeepSeek-V3.1',
      grok: 'meta-llama/Llama-3.3-70B-Instruct-Turbo'
    }
  },
  openrouter: {
    name: 'OpenRouter',
    url: 'https://openrouter.ai/api/v1/chat/completions',
    keyLink: '<a href="https://openrouter.ai/keys" target="_blank">Get an OpenRouter key &rarr;</a>',
    hint: 'OpenRouter aggregates many providers. Some models have free tiers.',
    tokenLimit: 4000,
    tokenLimitLabel: '4,000 TPM (varies by model)',
    models: {
      llama: 'meta-llama/llama-3.3-70b-instruct',
      qwen: 'qwen/qwen-2.5-72b-instruct',
      mixtral: 'mistralai/mixtral-8x7b-instruct',
      deepseek: 'deepseek/deepseek-chat-v3-0324',
      grok: 'meta-llama/llama-3.3-70b-instruct'
    }
  },
  xai: {
    name: 'xAI',
    url: 'https://api.x.ai/v1/chat/completions',
    keyLink: '<a href="https://console.x.ai" target="_blank">Get an xAI API key &rarr;</a>',
    hint: 'xAI provides access to Grok models.',
    tokenLimit: 100000,
    tokenLimitLabel: '100,000 TPM',
    models: {
      llama: 'grok-3-mini-fast',
      qwen: 'grok-3-mini-fast',
      mixtral: 'grok-3-mini-fast',
      deepseek: 'grok-3-mini-fast',
      grok: 'grok-3-mini-fast'
    }
  },
  ollama: {
    name: 'Ollama (Local)',
    url: 'http://localhost:11434/v1/chat/completions',
    keyLink: '',
    hint: 'Running locally — completely private.',
    tokenLimit: 128000,
    tokenLimitLabel: 'No limit (local)',
    models: {}
  }
};

const PRIVACY_INFO = {
  high: '<strong>High Privacy:</strong> Maximum privacy recommended. Use local mode (Ollama) so nothing leaves your computer. If using cloud, be aware that your messages are processed on external servers. No logs are kept by FreeLattice — everything stays in your browser\'s memory.',
  medium: '<strong>Medium Privacy:</strong> Your conversations are processed by your chosen cloud provider. Minimal metadata may be logged by the provider. Your API key and messages are never stored by FreeLattice. All data stays in your browser.',
  low: '<strong>Low Privacy:</strong> Standard cloud processing. Your provider may log conversations per their terms. FreeLattice itself still stores nothing remotely — your data remains in your browser. Review your provider\'s privacy policy for details.'
};

// ============================================
// φ-Root Encryption — adapted from Kirk Patrick Miller's Audit-Hash micro-service
// AES-GCM encryption with PBKDF2 key derivation using golden-ratio-derived salt
// ============================================

const PHI_SALT = new Uint8Array([
  0x1f, 0x9a, 0x0a, 0x8b, 0x4a, 0xf3, 0x63, 0xdc,
  0xb3, 0x4e, 0x99, 0x42, 0x7d, 0x15, 0x8f, 0xaa,
  0x2d, 0x30, 0xc4, 0xb1, 0xc7, 0x97, 0x09, 0xce,
  0xb5, 0x1b, 0x07, 0x2d, 0xac, 0x94, 0x1a, 0x55
]);

const PHI_STRING = '1.6180339887';

async function phiDeriveKey(providerName) {
  // φ-Root encryption — adapted from Kirk Patrick Miller's Audit-Hash micro-service
  const passphrase = providerName + PHI_STRING;
  const encoder = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    'raw', encoder.encode(passphrase), 'PBKDF2', false, ['deriveKey']
  );
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt: PHI_SALT, iterations: 100000, hash: 'SHA-256' },
    keyMaterial,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
}

async function phiEncrypt(plaintext, providerName) {
  // φ-Root encryption — adapted from Kirk Patrick Miller's Audit-Hash micro-service
  if (!plaintext) return null;
  const key = await phiDeriveKey(providerName);
  const encoder = new TextEncoder();
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encrypted = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv: iv },
    key,
    encoder.encode(plaintext)
  );
  // Store as base64: iv + ciphertext
  const combined = new Uint8Array(iv.length + encrypted.byteLength);
  combined.set(iv);
  combined.set(new Uint8Array(encrypted), iv.length);
  return btoa(String.fromCharCode(...combined));
}

async function phiDecrypt(encryptedB64, providerName) {
  // φ-Root encryption — adapted from Kirk Patrick Miller's Audit-Hash micro-service
  if (!encryptedB64) return null;
  try {
    const key = await phiDeriveKey(providerName);
    const combined = Uint8Array.from(atob(encryptedB64), c => c.charCodeAt(0));
    const iv = combined.slice(0, 12);
    const ciphertext = combined.slice(12);
    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv: iv },
      key,
      ciphertext
    );
    return new TextDecoder().decode(decrypted);
  } catch(e) {
    console.warn('φ-decrypt failed (provider context may have changed):', e.message);
    return null;
  }
}

async function phiHashData(data) {
  // SHA-256 with PhiSalt prepended — mirrors Kirk's HashLine() from hasher.go
  const encoder = new TextEncoder();
  const dataBytes = encoder.encode(data);
  const combined = new Uint8Array(PHI_SALT.length + dataBytes.length);
  combined.set(PHI_SALT);
  combined.set(dataBytes, PHI_SALT.length);
  const hashBuffer = await crypto.subtle.digest('SHA-256', combined);
  return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
}

// ============================================
// Input Sanitization
// ============================================

function sanitizeForDOM(str) {
  // Sanitize user-generated content for safe DOM insertion
  if (typeof str !== 'string') return '';
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function sanitizeFileName(name) {
  // Sanitize file names from drag-and-drop to prevent XSS
  if (typeof name !== 'string') return 'unnamed';
  return name.replace(/[<>"'&\/\\]/g, '_').replace(/\.\.+/g, '.').substring(0, 255);
}

// ============================================
// IndexedDB — Persistent Memory
// ============================================

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      const oldVersion = e.oldVersion;
      if (!db.objectStoreNames.contains(STORE_CONVERSATIONS)) {
        const convStore = db.createObjectStore(STORE_CONVERSATIONS, { keyPath: 'id' });
        convStore.createIndex('updatedAt', 'updatedAt', { unique: false });
      }
      if (!db.objectStoreNames.contains(STORE_MESSAGES)) {
        const msgStore = db.createObjectStore(STORE_MESSAGES, { keyPath: 'id', autoIncrement: true });
        msgStore.createIndex('conversationId', 'conversationId', { unique: false });
      }
      if (!db.objectStoreNames.contains(STORE_META)) {
        db.createObjectStore(STORE_META, { keyPath: 'key' });
      }
      // v2 migration: add lastMessage and contextNote fields to existing conversations
      // This is handled post-open in migrateToV2() since we can't read data during upgrade
    };
    req.onsuccess = (e) => resolve(e.target.result);
    req.onerror = (e) => reject(e.target.error);
  });
}

async function migrateToV2() {
  // Migrate existing conversations to have the new fields: lastMessage, contextNote, name (renamed from title)
  const conversations = await dbGetAll(STORE_CONVERSATIONS);
  let needsMigration = false;

  for (const conv of conversations) {
    let changed = false;

    // Ensure 'name' field exists (previously was 'title')
    if (conv.title && !conv.name) {
      conv.name = conv.title;
      changed = true;
    }
    if (!conv.name) {
      conv.name = conv.title || 'Default';
      changed = true;
    }

    // Ensure lastMessage field
    if (!conv.lastMessage) {
      // Try to get the last message for this conversation
      try {
        const msgs = await dbGetAllByIndex(STORE_MESSAGES, 'conversationId', conv.id);
        if (msgs.length > 0) {
          msgs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
          const lastMsg = msgs[0];
          conv.lastMessage = (lastMsg.content || '').substring(0, 80);
        } else {
          conv.lastMessage = '';
        }
      } catch(e) {
        conv.lastMessage = '';
      }
      changed = true;
    }

    // Ensure contextNote field
    if (conv.contextNote === undefined) {
      conv.contextNote = '';
      changed = true;
    }

    if (changed) {
      await dbPut(STORE_CONVERSATIONS, conv);
      needsMigration = true;
    }
  }

  // If there were no conversations at all, this is a fresh install — no migration needed
  // If there was exactly one conversation with default title, rename it to 'Default'
  if (conversations.length === 1 && (conversations[0].title === 'New Conversation' || conversations[0].name === 'New Conversation')) {
    const conv = conversations[0];
    conv.name = 'Default';
    await dbPut(STORE_CONVERSATIONS, conv);
  }

  if (needsMigration) {
    console.log('FreeLattice: Migrated conversations to v2 schema');
  }
}

function dbTx(storeName, mode) {
  const tx = state.db.transaction(storeName, mode);
  return tx.objectStore(storeName);
}

function dbGet(storeName, key) {
  return new Promise((resolve, reject) => {
    const req = dbTx(storeName, 'readonly').get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function dbPut(storeName, value) {
  return new Promise((resolve, reject) => {
    const req = dbTx(storeName, 'readwrite').put(value);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function dbDelete(storeName, key) {
  return new Promise((resolve, reject) => {
    const req = dbTx(storeName, 'readwrite').delete(key);
    req.onsuccess = () => resolve();
    req.onerror = () => reject(req.error);
  });
}

function dbGetAll(storeName) {
  return new Promise((resolve, reject) => {
    const req = dbTx(storeName, 'readonly').getAll();
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function dbClear(storeName) {
  return new Promise((resolve, reject) => {
    const req = dbTx(storeName, 'readwrite').clear();
    req.onsuccess = () => resolve();
    req.onerror = () => reject(req.error);
  });
}

function dbGetAllByIndex(storeName, indexName, value) {
  return new Promise((resolve, reject) => {
    const store = dbTx(storeName, 'readonly');
    const idx = store.index(indexName);
    const req = idx.getAll(value);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function dbCount(storeName) {
  return new Promise((resolve, reject) => {
    const req = dbTx(storeName, 'readonly').count();
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
}

async function createConversation(customName, contextNote) {
  // Auto-number if no custom name
  let name = customName;
  if (!name) {
    const allConvs = await dbGetAll(STORE_CONVERSATIONS);
    const num = allConvs.length + 1;
    name = 'Conversation ' + num;
  }
  const conv = {
    id: generateId(),
    name: name,
    title: name, // keep title for backward compat
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    lastMessage: '',
    contextNote: contextNote || ''
  };
  await dbPut(STORE_CONVERSATIONS, conv);
  state.currentConversationId = conv.id;
  state.currentConvContextNote = conv.contextNote || '';
  state.chatHistory = [];
  await refreshConversationList();
  return conv;
}

async function saveMessage(role, content) {
  if (!state.currentConversationId) return;
  const msg = {
    conversationId: state.currentConversationId,
    role: role,
    content: content,
    timestamp: new Date().toISOString()
  };
  await dbPut(STORE_MESSAGES, msg);

  // Update conversation timestamp, lastMessage, and auto-name
  const conv = await dbGet(STORE_CONVERSATIONS, state.currentConversationId);
  if (conv) {
    conv.updatedAt = new Date().toISOString();
    conv.lastMessage = content.substring(0, 80);
    // Auto-name from first user message if still default
    if (role === 'user' && (conv.name === 'New Conversation' || /^Conversation \d+$/.test(conv.name))) {
      const autoName = content.substring(0, 60) + (content.length > 60 ? '...' : '');
      conv.name = autoName;
      conv.title = autoName; // backward compat
    }
    await dbPut(STORE_CONVERSATIONS, conv);
    refreshConversationList();
  }

  // Check if we need to generate a memory summary
  const allMsgs = await dbGetAllByIndex(STORE_MESSAGES, 'conversationId', state.currentConversationId);
  if (allMsgs.length > 0 && allMsgs.length % 10 === 0) {
    generateMemorySummary();
  }

  updateMemoryStats();
}

async function loadLastConversation() {
  const conversations = await dbGetAll(STORE_CONVERSATIONS);
  if (conversations.length === 0) {
    await createConversation();
    return;
  }

  // Sort by updatedAt descending
  conversations.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
  const latest = conversations[0];
  await switchToConversation(latest.id);
}

async function switchToConversation(convId) {
  // Save current conversation state (chatHistory is already persisted per-message)
  // Load the target conversation
  const conv = await dbGet(STORE_CONVERSATIONS, convId);
  if (!conv) return;

  state.currentConversationId = conv.id;
  state.currentConvContextNote = conv.contextNote || '';

  // Load messages
  const messages = await dbGetAllByIndex(STORE_MESSAGES, 'conversationId', conv.id);
  messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

  state.chatHistory = messages.map(m => ({ role: m.role, content: m.content }));

  // Render messages in chat
  const container = document.getElementById('chatMessages');
  container.innerHTML = '';

  if (messages.length === 0) {
    const div = document.createElement('div');
    div.className = 'chat-message system';
    div.textContent = 'Welcome to FreeLattice v2.5. Configure your model and provider above, then start chatting. Connect to peers in the Mesh tab to share knowledge.';
    container.appendChild(div);
  } else {
    const sysDiv = document.createElement('div');
    sysDiv.className = 'chat-message system';
    sysDiv.textContent = 'Conversation restored: ' + (conv.name || 'Untitled');
    container.appendChild(sysDiv);

    for (const msg of messages) {
      addChatMessage(msg.role, msg.content, true);
    }
  }

  container.scrollTop = container.scrollHeight;
  await refreshConversationList();
}

async function generateMemorySummary() {
  // Gather all messages across all conversations
  const allMsgs = await dbGetAll(STORE_MESSAGES);
  if (allMsgs.length < 10) return;

  // Extract user messages for summary
  const userMsgs = allMsgs
    .filter(m => m.role === 'user')
    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
    .slice(0, 50)
    .map(m => m.content);

  if (userMsgs.length === 0) return;

  // Build a simple extraction of key facts from user messages
  // We look for patterns like names, preferences, projects
  const existing = state.memorySummary || '';
  const newFacts = [];

  for (const msg of userMsgs) {
    // Look for "my name is", "I am", "I work", "I like", "my project" patterns
    const patterns = [
      /my name is\s+([^.!?,\n]+)/gi,
      /I(?:'m| am)\s+(?:a |an )?([^.!?,\n]{3,40})/gi,
      /I work (?:at|on|for|as)\s+([^.!?,\n]+)/gi,
      /I(?:'m| am) (?:working on|building|creating)\s+([^.!?,\n]+)/gi,
      /I (?:like|love|prefer|enjoy)\s+([^.!?,\n]+)/gi,
      /my (?:project|app|website|tool) (?:is |called )?([^.!?,\n]+)/gi,
      /I live in\s+([^.!?,\n]+)/gi,
      /call me\s+([^.!?,\n]+)/gi
    ];

    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(msg)) !== null) {
        const fact = match[0].trim();
        if (fact.length > 5 && fact.length < 200 && !existing.includes(fact) && !newFacts.includes(fact)) {
          newFacts.push(fact);
        }
      }
    }
  }

  if (newFacts.length > 0) {
    const updated = existing ? existing + '\n' + newFacts.join('\n') : newFacts.join('\n');
    state.memorySummary = updated;
    await dbPut(STORE_META, { key: 'memorySummary', value: updated });
    document.getElementById('memorySummaryEditor').value = updated;
    updateMemoryStats();
    showToast('Memory summary updated with new facts.');
  }
}

async function loadMemorySummary() {
  const data = await dbGet(STORE_META, 'memorySummary');
  state.memorySummary = data ? data.value : '';
  document.getElementById('memorySummaryEditor').value = state.memorySummary;
}

async function saveMemorySummary() {
  state.memorySummary = document.getElementById('memorySummaryEditor').value;
  await dbPut(STORE_META, { key: 'memorySummary', value: state.memorySummary });
  updateMemoryStats();
  showToast('Memory summary saved.');
}

async function loadCustomSystemPrompt() {
  const data = await dbGet(STORE_META, 'customSystemPrompt');
  state.customSystemPrompt = data ? data.value : null;
  document.getElementById('systemPromptEditor').value = state.customSystemPrompt || DEFAULT_SYSTEM_PROMPT;
}

async function saveSystemPrompt() {
  const val = document.getElementById('systemPromptEditor').value.trim();
  if (val && val !== DEFAULT_SYSTEM_PROMPT) {
    state.customSystemPrompt = val;
    await dbPut(STORE_META, { key: 'customSystemPrompt', value: val });
  } else {
    state.customSystemPrompt = null;
    try { await dbDelete(STORE_META, 'customSystemPrompt'); } catch(e) {}
  }
  showToast('System prompt saved.');
}

function resetSystemPrompt() {
  document.getElementById('systemPromptEditor').value = DEFAULT_SYSTEM_PROMPT;
  state.customSystemPrompt = null;
  dbDelete(STORE_META, 'customSystemPrompt').catch(() => {});
  showToast('System prompt reset to default.');
}

async function updateMemoryStats() {
  try {
    const msgCount = await dbCount(STORE_MESSAGES);
    const convCount = await dbCount(STORE_CONVERSATIONS);
    const summaryLines = state.memorySummary ? state.memorySummary.split('\n').filter(l => l.trim()).length : 0;
    document.getElementById('memMsgCount').textContent = msgCount;
    document.getElementById('memConvCount').textContent = convCount;
    document.getElementById('memSummaryLen').textContent = summaryLines;
  } catch(e) {}
}

async function exportMemory() {
  try {
    const conversations = await dbGetAll(STORE_CONVERSATIONS);
    const messages = await dbGetAll(STORE_MESSAGES);
    const meta = await dbGetAll(STORE_META);

    const data = {
      version: 2.1,
      exportedAt: new Date().toISOString(),
      conversations,
      messages,
      meta
    };

    // Compute φ-hash integrity signature (mirrors Kirk's HashLine from hasher.go)
    const dataForHash = JSON.stringify({ conversations, messages, meta });
    data.phiHash = await phiHashData(dataForHash);

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `freelattice-memory-${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
    showToast('Memory exported with φ-hash integrity signature.');
  } catch(e) {
    showToast('Error exporting memory: ' + e.message);
  }
}

async function importMemory(event) {
  const file = event.target.files[0];
  if (!file) return;
  event.target.value = '';

  try {
    const text = await file.text();
    const data = JSON.parse(text);

    if (!data.conversations || !data.messages) {
      throw new Error('Invalid memory file format.');
    }

    // Verify φ-hash integrity if present (mirrors Kirk's audit-hash verification pattern)
    if (data.phiHash) {
      const dataForHash = JSON.stringify({
        conversations: data.conversations,
        messages: data.messages,
        meta: data.meta || []
      });
      const computedHash = await phiHashData(dataForHash);
      if (computedHash !== data.phiHash) {
        const proceed = await showConfirm(
          'φ-Hash Integrity Warning',
          'The memory file\'s integrity hash does not match. This file may have been modified outside of FreeLattice. Do you still want to import it?'
        );
        if (!proceed) {
          showToast('Import cancelled — integrity check failed.');
          return;
        }
      } else {
        showToast('φ-hash integrity verified.');
      }
    }

    // Import conversations
    for (const conv of data.conversations) {
      await dbPut(STORE_CONVERSATIONS, conv);
    }

    // Import messages
    for (const msg of data.messages) {
      await dbPut(STORE_MESSAGES, msg);
    }

    // Import meta
    if (data.meta) {
      for (const m of data.meta) {
        await dbPut(STORE_META, m);
      }
    }

    // Reload
    await loadMemorySummary();
    await loadCustomSystemPrompt();
    await loadLastConversation();
    await updateMemoryStats();
    showToast('Memory imported successfully.');
  } catch(e) {
    showToast('Error importing memory: ' + e.message);
  }
}

function confirmClearMemory() {
  showConfirm('Clear All Memory?', 'This will permanently delete all conversations, messages, and memory summaries. This cannot be undone.').then(async (confirmed) => {
    if (confirmed) {
      await dbClear(STORE_CONVERSATIONS);
      await dbClear(STORE_MESSAGES);
      await dbClear(STORE_META);
      state.memorySummary = '';
      state.customSystemPrompt = null;
      state.chatHistory = [];
      state.currentConvContextNote = '';
      document.getElementById('memorySummaryEditor').value = '';
      document.getElementById('systemPromptEditor').value = DEFAULT_SYSTEM_PROMPT;
      await createConversation();
      const container = document.getElementById('chatMessages');
      container.innerHTML = '<div class="chat-message system">Memory cleared. Starting fresh.</div>';
      await updateMemoryStats();
      await refreshConversationList();
      showToast('All memory cleared.');
    }
  });
}

async function startNewConversation() {
  // Called from the old "New Conversation" button — now opens the modal
  openNewConvModal();
}

function openNewConvModal() {
  document.getElementById('newConvName').value = '';
  document.getElementById('newConvContext').value = '';
  document.getElementById('newConvOverlay').classList.remove('hidden');
  document.getElementById('newConvName').focus();
}

function closeNewConvModal() {
  document.getElementById('newConvOverlay').classList.add('hidden');
}

async function confirmNewConversation() {
  const name = document.getElementById('newConvName').value.trim();
  const contextNote = document.getElementById('newConvContext').value.trim();
  closeNewConvModal();

  await createConversation(name || '', contextNote);
  state.chatHistory = [];
  const container = document.getElementById('chatMessages');
  container.innerHTML = '<div class="chat-message system">New conversation started.' + (contextNote ? ' Topic: ' + escapeHtml(contextNote) : '') + ' Your memory summary carries forward.</div>';
  await updateMemoryStats();
}

// ============================================
// Conversation Sidebar — UI Logic
// ============================================

function toggleConvSidebar() {
  const sidebar = document.getElementById('convSidebar');
  const backdrop = document.getElementById('convBackdrop');
  state.convSidebarOpen = !state.convSidebarOpen;

  if (state.convSidebarOpen) {
    sidebar.classList.remove('collapsed');
    backdrop.classList.remove('hidden');
    refreshConversationList();
  } else {
    sidebar.classList.add('collapsed');
    backdrop.classList.add('hidden');
  }
}

async function refreshConversationList() {
  if (!state.db) return;
  const conversations = await dbGetAll(STORE_CONVERSATIONS);
  conversations.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
  state.conversationsList = conversations;
  renderConversationList(conversations);
  updateConvCounts(conversations.length);
}

function updateConvCounts(count) {
  const badge = document.getElementById('convCountBadge');
  const sidebarCount = document.getElementById('convSidebarCount');
  if (badge) badge.textContent = '(' + count + ')';
  if (sidebarCount) sidebarCount.textContent = '(' + count + ')';
}

function renderConversationList(conversations) {
  const list = document.getElementById('convList');
  if (!list) return;

  const searchTerm = (document.getElementById('convSearchInput')?.value || '').toLowerCase();
  const filtered = searchTerm
    ? conversations.filter(c => (c.name || '').toLowerCase().includes(searchTerm) || (c.lastMessage || '').toLowerCase().includes(searchTerm))
    : conversations;

  if (filtered.length === 0) {
    list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted); font-size: 0.82rem;">' +
      (searchTerm ? 'No conversations match your search.' : 'No conversations yet.') + '</div>';
    return;
  }

  list.innerHTML = filtered.map(conv => {
    const isActive = conv.id === state.currentConversationId;
    const name = escapeHtml(conv.name || conv.title || 'Untitled');
    const preview = escapeHtml((conv.lastMessage || '').substring(0, 60));
    const time = formatRelativeTime(conv.updatedAt);
    const contextNote = conv.contextNote ? '<div class="conv-item-context">' + escapeHtml(conv.contextNote.substring(0, 40)) + '</div>' : '';

    return '<div class="conv-item' + (isActive ? ' active' : '') + '" data-conv-id="' + conv.id + '" onclick="handleConvClick(\'' + conv.id + '\')">' +
      '<div class="conv-item-top">' +
        '<span class="conv-item-name" ondblclick="startRenameConv(event, \'' + conv.id + '\')" title="Double-click to rename">' + name + '</span>' +
        '<button class="conv-item-delete" onclick="deleteConversation(event, \'' + conv.id + '\')" title="Delete conversation">&#10005;</button>' +
      '</div>' +
      (preview ? '<div class="conv-item-preview">' + preview + '</div>' : '') +
      contextNote +
      '<div class="conv-item-time">' + time + '</div>' +
    '</div>';
  }).join('');
}

function filterConversations() {
  renderConversationList(state.conversationsList);
}

function formatRelativeTime(isoString) {
  if (!isoString) return '';
  const date = new Date(isoString);
  const now = new Date();
  const diffMs = now - date;
  const diffMin = Math.floor(diffMs / 60000);
  const diffHr = Math.floor(diffMs / 3600000);
  const diffDay = Math.floor(diffMs / 86400000);

  if (diffMin < 1) return 'just now';
  if (diffMin < 60) return diffMin + 'm ago';
  if (diffHr < 24) return diffHr + 'h ago';
  if (diffDay < 7) return diffDay + 'd ago';
  return date.toLocaleDateString();
}

async function handleConvClick(convId) {
  if (convId === state.currentConversationId) return;
  await switchToConversation(convId);
  await updateMemoryStats();

  // On mobile, close sidebar after switching
  if (window.innerWidth <= 768) {
    toggleConvSidebar();
  }
}

function startRenameConv(event, convId) {
  event.stopPropagation();
  const nameSpan = event.target;
  const currentName = nameSpan.textContent;

  const input = document.createElement('input');
  input.value = currentName;
  input.style.cssText = 'background: var(--bg-input); border: 1px solid var(--accent); border-radius: 3px; color: var(--text-primary); font-size: 0.82rem; font-family: var(--font); padding: 1px 4px; width: 100%; outline: none;';

  nameSpan.textContent = '';
  nameSpan.appendChild(input);
  input.focus();
  input.select();

  const finishRename = async () => {
    const newName = input.value.trim() || currentName;
    nameSpan.textContent = newName;

    const conv = await dbGet(STORE_CONVERSATIONS, convId);
    if (conv) {
      conv.name = newName;
      conv.title = newName;
      await dbPut(STORE_CONVERSATIONS, conv);
      await refreshConversationList();
    }
  };

  input.addEventListener('blur', finishRename);
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
    if (e.key === 'Escape') { input.value = currentName; input.blur(); }
  });
}

async function deleteConversation(event, convId) {
  event.stopPropagation();

  const conv = await dbGet(STORE_CONVERSATIONS, convId);
  const convName = conv ? (conv.name || 'this conversation') : 'this conversation';

  const confirmed = await showConfirm('Delete Conversation?', 'Delete "' + convName + '"? This will permanently remove all messages in this conversation. This cannot be undone.');
  if (!confirmed) return;

  // Delete all messages for this conversation
  const messages = await dbGetAllByIndex(STORE_MESSAGES, 'conversationId', convId);
  for (const msg of messages) {
    await dbDelete(STORE_MESSAGES, msg.id);
  }

  // Delete the conversation
  await dbDelete(STORE_CONVERSATIONS, convId);

  // If we deleted the active conversation, switch to another or create new
  if (convId === state.currentConversationId) {
    const remaining = await dbGetAll(STORE_CONVERSATIONS);
    if (remaining.length > 0) {
      remaining.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
      await switchToConversation(remaining[0].id);
    } else {
      await createConversation();
      const container = document.getElementById('chatMessages');
      container.innerHTML = '<div class="chat-message system">All conversations deleted. Starting fresh. Your memory summary carries forward.</div>';
    }
  }

  await refreshConversationList();
  await updateMemoryStats();
  showToast('Conversation deleted.');
}

// ============================================
// File System Access API — Workspace
// ============================================

async function openProjectFolder() {
  try {
    const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
    state.workspaceDirHandle = dirHandle;
    document.getElementById('workspaceFolderName').innerHTML = '<span style="color: var(--accent);">&#128194; ' + escapeHtml(dirHandle.name) + '</span>';
    document.getElementById('refreshFolderBtn').style.display = '';
    await refreshProjectFolder();
  } catch(e) {
    if (e.name !== 'AbortError') {
      showToast('Error opening folder: ' + e.message);
    }
  }
}

async function refreshProjectFolder() {
  if (!state.workspaceDirHandle) return;
  try {
    const files = [];
    await scanDirectory(state.workspaceDirHandle, '', files);
    state.workspaceFiles = files;
    renderWorkspaceTree(files);
  } catch(e) {
    showToast('Error reading folder: ' + e.message);
  }
}

async function scanDirectory(dirHandle, prefix, results, depth) {
  depth = depth || 0;
  if (depth > 8) return; // prevent infinite recursion
  try {
    for await (const entry of dirHandle.values()) {
      const path = prefix ? prefix + '/' + entry.name : entry.name;
      if (entry.name.startsWith('.') || entry.name === 'node_modules' || entry.name === '__pycache__') continue;
      if (entry.kind === 'file') {
        results.push({ kind: 'file', name: entry.name, path: path, handle: entry, depth: depth });
      } else if (entry.kind === 'directory') {
        results.push({ kind: 'directory', name: entry.name, path: path, handle: entry, depth: depth });
        await scanDirectory(entry, path, results, depth + 1);
      }
    }
  } catch(e) { /* permission denied or similar */ }
}

function renderWorkspaceTree(files) {
  const tree = document.getElementById('workspaceTree');
  tree.style.display = files.length > 0 ? '' : 'none';

  // Sort: directories first, then files, alphabetically
  files.sort((a, b) => {
    if (a.kind !== b.kind) return a.kind === 'directory' ? -1 : 1;
    return a.path.localeCompare(b.path);
  });

  tree.innerHTML = files.map((f, i) => {
    const icon = f.kind === 'directory' ? '&#128193;' : '&#128196;';
    const indent = f.depth * 16;
    return '<div class="file-tree-item" onclick="workspaceFileClick(' + i + ')" title="' + escapeHtml(f.path) + '">' +
      '<span class="ft-indent" style="width:' + indent + 'px;"></span>' +
      '<span class="ft-icon">' + icon + '</span>' +
      '<span class="ft-name">' + escapeHtml(f.name) + '</span>' +
      '</div>';
  }).join('');
}

async function workspaceFileClick(index) {
  const file = state.workspaceFiles[index];
  if (!file || file.kind !== 'file') return;

  try {
    const fileObj = await file.handle.getFile();
    const content = await fileObj.text();
    state.workspacePreviewFile = file;
    state.workspacePreviewContent = content;

    document.getElementById('previewFileName').textContent = file.path;
    document.getElementById('previewFileContent').textContent = content;
    document.getElementById('workspaceFilePreview').style.display = '';
  } catch(e) {
    showToast('Error reading file: ' + e.message);
  }
}

function loadFileToContext() {
  if (!state.workspacePreviewFile || !state.workspacePreviewContent) return;
  const name = state.workspacePreviewFile.path;
  const content = state.workspacePreviewContent;

  if (state.contextFiles.some(f => f.name === name)) {
    showToast('"' + name + '" is already in context.');
    return;
  }

  state.contextFiles.push({ name: name, size: content.length, content: content });
  renderFileList();
  showToast('Loaded "' + name + '" into chat context.');
}

async function saveFileToWorkspace(path, content) {
  if (!state.workspaceDirHandle) {
    showToast('No workspace folder open. Open a project folder first.');
    return false;
  }

  try {
    const parts = path.split('/');
    let dirHandle = state.workspaceDirHandle;

    // Navigate/create subdirectories
    for (let i = 0; i < parts.length - 1; i++) {
      dirHandle = await dirHandle.getDirectoryHandle(parts[i], { create: true });
    }

    const fileName = parts[parts.length - 1];
    const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();

    showToast('Saved "' + path + '" to workspace.');
    refreshProjectFolder();
    return true;
  } catch(e) {
    showToast('Error saving file: ' + e.message);
    return false;
  }
}

// ============================================
// GitHub Integration
// ============================================

async function saveGhToken() {
  // φ-Root encryption — adapted from Kirk Patrick Miller's Audit-Hash micro-service
  state.ghToken = document.getElementById('ghToken').value.trim();
  if (state.ghToken) {
    const encrypted = await phiEncrypt(state.ghToken, 'github');
    localStorage.setItem('fl_ghToken_enc', encrypted);
    localStorage.removeItem('fl_ghToken'); // Remove any legacy plaintext token
    document.getElementById('ghTokenPhiIndicator').style.display = '';
    verifyGhToken();
  } else {
    localStorage.removeItem('fl_ghToken_enc');
    localStorage.removeItem('fl_ghToken');
    document.getElementById('ghConnected').style.display = 'none';
    document.getElementById('ghTokenPhiIndicator').style.display = 'none';
  }
}

async function loadGhToken() {
  // φ-Root encryption — adapted from Kirk Patrick Miller's Audit-Hash micro-service
  const encToken = localStorage.getItem('fl_ghToken_enc');
  if (encToken) {
    const decrypted = await phiDecrypt(encToken, 'github');
    if (decrypted) {
      state.ghToken = decrypted;
      document.getElementById('ghToken').value = decrypted;
      document.getElementById('ghTokenPhiIndicator').style.display = '';
      verifyGhToken();
      return;
    }
  }
  // Fallback: migrate legacy plaintext token
  const legacyToken = localStorage.getItem('fl_ghToken');
  if (legacyToken) {
    state.ghToken = legacyToken;
    document.getElementById('ghToken').value = legacyToken;
    const encrypted = await phiEncrypt(legacyToken, 'github');
    localStorage.setItem('fl_ghToken_enc', encrypted);
    localStorage.removeItem('fl_ghToken');
    document.getElementById('ghTokenPhiIndicator').style.display = '';
    verifyGhToken();
  }
}

async function verifyGhToken() {
  if (!state.ghToken) return;
  try {
    const res = await fetch('https://api.github.com/user', {
      headers: { 'Authorization': 'Bearer ' + state.ghToken }
    });
    if (!res.ok) throw new Error('Invalid token');
    const data = await res.json();
    state.ghUsername = data.login;
    document.getElementById('ghUsername').textContent = data.login;
    document.getElementById('ghConnected').style.display = '';
  } catch(e) {
    document.getElementById('ghConnected').style.display = 'none';
    showToast('GitHub: ' + e.message);
  }
}

async function openGhRepo() {
  const input = document.getElementById('ghRepoUrl').value.trim();
  if (!input) { showToast('Enter a repository URL or owner/repo.'); return; }

  // Parse owner/repo from URL or direct input
  let owner, repo;
  const urlMatch = input.match(/github\.com\/([^/]+)\/([^/\s?#]+)/);
  if (urlMatch) {
    owner = urlMatch[1];
    repo = urlMatch[2].replace(/\.git$/, '');
  } else {
    const parts = input.split('/');
    if (parts.length === 2) {
      owner = parts[0];
      repo = parts[1];
    } else {
      showToast('Invalid format. Use owner/repo or a GitHub URL.');
      return;
    }
  }

  try {
    // Get default branch
    const repoRes = await fetch('https://api.github.com/repos/' + owner + '/' + repo, {
      headers: { 'Authorization': 'Bearer ' + state.ghToken }
    });
    if (!repoRes.ok) throw new Error('Repository not found or access denied.');
    const repoData = await repoRes.json();
    state.ghBranch = repoData.default_branch || 'main';
    state.ghRepo = { owner, repo, fullName: owner + '/' + repo };

    // Get file tree
    const treeRes = await fetch('https://api.github.com/repos/' + owner + '/' + repo + '/git/trees/' + state.ghBranch + '?recursive=1', {
      headers: { 'Authorization': 'Bearer ' + state.ghToken }
    });
    if (!treeRes.ok) throw new Error('Could not fetch file tree.');
    const treeData = await treeRes.json();

    state.ghTreeData = (treeData.tree || []).filter(t => t.type === 'blob').map(t => ({
      path: t.path,
      sha: t.sha,
      size: t.size
    }));

    document.getElementById('ghRepoName').textContent = owner + '/' + repo;
    document.getElementById('ghRepoBranch').textContent = '(' + state.ghBranch + ')';
    document.getElementById('ghRepoInfo').style.display = '';
    document.getElementById('ghPushBtn').style.display = '';

    renderGhTree();
  } catch(e) {
    showToast('GitHub: ' + e.message);
  }
}

function renderGhTree() {
  const tree = document.getElementById('ghTree');
  const files = state.ghTreeData;

  tree.innerHTML = files.map((f, i) => {
    const parts = f.path.split('/');
    const name = parts[parts.length - 1];
    const depth = parts.length - 1;
    const indent = depth * 16;
    return '<div class="file-tree-item" onclick="ghFileClick(' + i + ')" title="' + escapeHtml(f.path) + '">' +
      '<span class="ft-indent" style="width:' + indent + 'px;"></span>' +
      '<span class="ft-icon">&#128196;</span>' +
      '<span class="ft-name">' + escapeHtml(name) + '</span>' +
      '</div>';
  }).join('');
}

async function ghFileClick(index) {
  const file = state.ghTreeData[index];
  if (!file || !state.ghRepo) return;

  try {
    const res = await fetch('https://api.github.com/repos/' + state.ghRepo.owner + '/' + state.ghRepo.repo + '/contents/' + file.path + '?ref=' + state.ghBranch, {
      headers: { 'Authorization': 'Bearer ' + state.ghToken }
    });
    if (!res.ok) throw new Error('Could not read file.');
    const data = await res.json();

    let content;
    if (data.encoding === 'base64') {
      content = atob(data.content.replace(/\n/g, ''));
    } else {
      content = data.content;
    }

    state.ghPreviewFile = file;
    state.ghPreviewContent = content;
    state.ghPreviewSha = data.sha;

    document.getElementById('ghPreviewFileName').textContent = file.path;
    document.getElementById('ghPreviewFileContent').textContent = content;
    document.getElementById('ghFilePreview').style.display = '';
  } catch(e) {
    showToast('GitHub: ' + e.message);
  }
}

function loadGhFileToContext() {
  if (!state.ghPreviewFile || !state.ghPreviewContent) return;
  const name = 'gh:' + state.ghPreviewFile.path;
  const content = state.ghPreviewContent;

  if (state.contextFiles.some(f => f.name === name)) {
    showToast('"' + name + '" is already in context.');
    return;
  }

  state.contextFiles.push({ name: name, size: content.length, content: content, active: true, summary: null, summaryContent: null, useSummary: false });
  renderFileList();
  updateContextBudget();
  showToast('Loaded "' + state.ghPreviewFile.path + '" from GitHub into chat context.');
}

async function pushGhChanges() {
  if (!state.ghRepo || state.ghPendingChanges.length === 0) {
    showToast('No pending changes to push.');
    return;
  }

  const confirmed = await showConfirm('Push to GitHub?', 'This will push ' + state.ghPendingChanges.length + ' file(s) to ' + state.ghRepo.fullName + ' (' + state.ghBranch + ').');
  if (!confirmed) return;

  let success = 0;
  for (const change of state.ghPendingChanges) {
    try {
      // Get current file SHA if it exists
      let sha = null;
      try {
        const existing = await fetch('https://api.github.com/repos/' + state.ghRepo.owner + '/' + state.ghRepo.repo + '/contents/' + change.path + '?ref=' + state.ghBranch, {
          headers: { 'Authorization': 'Bearer ' + state.ghToken }
        });
        if (existing.ok) {
          const data = await existing.json();
          sha = data.sha;
        }
      } catch(e) {}

      const body = {
        message: 'Update ' + change.path + ' via FreeLattice v2.2',
        content: btoa(unescape(encodeURIComponent(change.content))),
        branch: state.ghBranch
      };
      if (sha) body.sha = sha;

      const res = await fetch('https://api.github.com/repos/' + state.ghRepo.owner + '/' + state.ghRepo.repo + '/contents/' + change.path, {
        method: 'PUT',
        headers: {
          'Authorization': 'Bearer ' + state.ghToken,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
      });

      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.message || 'Push failed');
      }
      success++;
    } catch(e) {
      showToast('Error pushing ' + change.path + ': ' + e.message);
    }
  }

  if (success > 0) {
    showToast('Pushed ' + success + ' file(s) to GitHub.');
    state.ghPendingChanges = [];
    // Refresh tree
    openGhRepo();
  }
}

function addGhPendingChange(path, content) {
  const existing = state.ghPendingChanges.findIndex(c => c.path === path);
  if (existing >= 0) {
    state.ghPendingChanges[existing].content = content;
  } else {
    state.ghPendingChanges.push({ path, content });
  }
  document.getElementById('ghPushBtn').style.display = '';
  showToast('Staged "' + path + '" for GitHub push. (' + state.ghPendingChanges.length + ' pending)');
}

// ============================================
// Tab Navigation
// ============================================

function switchTab(tabId) {
  document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tabId));
  document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.toggle('active', panel.id === 'tab-' + tabId));
}

// ============================================
// Toast & Confirm Dialogs
// ============================================

function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.classList.add('show');
  clearTimeout(toast._timer);
  toast._timer = setTimeout(() => toast.classList.remove('show'), 3500);
}

function showConfirm(title, message) {
  return new Promise((resolve) => {
    document.getElementById('confirmTitle').textContent = title;
    document.getElementById('confirmMessage').textContent = message;
    document.getElementById('confirmOverlay').classList.remove('hidden');
    state.confirmResolve = resolve;
  });
}

function closeConfirm(result) {
  document.getElementById('confirmOverlay').classList.add('hidden');
  if (state.confirmResolve) {
    state.confirmResolve(result);
    state.confirmResolve = null;
  }
}

// ============================================
// Initialization
// ============================================

document.addEventListener('DOMContentLoaded', async () => {
  // Open IndexedDB
  try {
    state.db = await openDB();
  } catch(e) {
    console.error('IndexedDB error:', e);
  }

  // Load saved settings from localStorage
  const savedProvider = localStorage.getItem('fl_provider');
  if (savedProvider && PROVIDERS[savedProvider]) {
    state.provider = savedProvider;
    document.getElementById('providerSelect').value = savedProvider;
  }

  const savedModel = localStorage.getItem('fl_model');
  if (savedModel) {
    state.model = savedModel;
    document.getElementById('modelSelect').value = savedModel;
  }

  const savedPrivacy = localStorage.getItem('fl_privacy');
  if (savedPrivacy) {
    state.privacy = savedPrivacy;
    document.getElementById('privacySelect').value = savedPrivacy;
  }

  const savedLocal = localStorage.getItem('fl_isLocal');
  if (savedLocal === 'true') {
    state.isLocal = true;
    document.getElementById('localToggle').checked = true;
  }

  const savedSuggestions = localStorage.getItem('fl_suggestions');
  if (savedSuggestions) {
    try { state.suggestions = JSON.parse(savedSuggestions); } catch(e) {}
  }

  // Load φ-encrypted API key
  await loadApiKey();

  // Check if first visit
  const visited = localStorage.getItem('fl_visited');
  if (visited) {
    document.getElementById('welcomeOverlay').classList.add('hidden');
  }

  // Apply initial state
  handleLocalToggle(true);
  handleProviderChange(true);
  handlePrivacyChange();
  updateStatus();

  // Setup drag and drop
  setupDropZone();

  // Auto-resize chat input
  const chatInput = document.getElementById('chatInput');
  chatInput.addEventListener('input', () => {
    chatInput.style.height = 'auto';
    chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
  });

  // Load memory data from IndexedDB
  if (state.db) {
    await migrateToV2();
    await loadMemorySummary();
    await loadCustomSystemPrompt();
    await loadLastConversation();
    await updateMemoryStats();
    await refreshConversationList();
  }

  // Load φ-encrypted GitHub token
  await loadGhToken();

  // Check File System Access API support
  if (!('showDirectoryPicker' in window)) {
    document.getElementById('fsApiSupported').style.display = 'none';
    document.getElementById('fsApiUnsupported').style.display = '';
  }

  // Initialize voice features
  initVoiceInput();
  initVoiceOutput();
  loadVoiceSettings();

  // Initialize Smart Context Management
  loadContextSettings();
  updateTokenLimitForProvider();
  updateContextBudget();

  // Initialize Mesh Network
  meshInit();
});

// ---- Welcome ----
function closeWelcome() {
  document.getElementById('welcomeOverlay').classList.add('hidden');
  localStorage.setItem('fl_visited', 'true');
}

// ---- Music ----
function initMusic() {
  const audio = document.getElementById('bgMusic');
  const btn = document.getElementById('musicToggle');

  btn.addEventListener('click', () => {
    if (state.musicPlaying) {
      audio.pause();
      state.musicPlaying = false;
      btn.classList.remove('active');
      btn.innerHTML = '&#9834;';
    } else {
      audio.volume = 0.15;
      audio.play().then(() => {
        state.musicPlaying = true;
        btn.classList.add('active');
        btn.innerHTML = '&#9835;';
      }).catch(() => {
        btn.innerHTML = '&#9834;';
      });
    }
  });
}
initMusic();

// ---- Local/Cloud Toggle ----
function handleLocalToggle(init) {
  const isLocal = document.getElementById('localToggle').checked;
  state.isLocal = isLocal;

  const providerGroup = document.getElementById('providerGroup');
  const apiKeyGroup = document.getElementById('apiKeyGroup');
  const ollamaModelGroup = document.getElementById('ollamaModelGroup');
  const ollamaInstructions = document.getElementById('ollamaInstructions');
  const cloudLabel = document.getElementById('cloudLabel');
  const localLabel = document.getElementById('localLabel');

  if (isLocal) {
    providerGroup.classList.add('hidden');
    apiKeyGroup.classList.add('hidden');
    ollamaModelGroup.classList.remove('hidden');
    ollamaInstructions.classList.remove('hidden');
    cloudLabel.classList.remove('active');
    localLabel.classList.add('active');
    state.provider = 'ollama';
  } else {
    providerGroup.classList.remove('hidden');
    apiKeyGroup.classList.remove('hidden');
    ollamaModelGroup.classList.add('hidden');
    ollamaInstructions.classList.add('hidden');
    cloudLabel.classList.add('active');
    localLabel.classList.remove('active');
    state.provider = document.getElementById('providerSelect').value;
  }

  if (!init) {
    localStorage.setItem('fl_isLocal', isLocal);
    updateTokenLimitForProvider();
    updateStatus();
  }
}

// ---- Model Change ----
function handleModelChange() {
  state.model = document.getElementById('modelSelect').value;
  localStorage.setItem('fl_model', state.model);
  updateModelHint();
  updateStatus();
}

function updateModelHint() {
  const hints = {
    llama: 'Llama by Meta — powerful, versatile, and widely supported.',
    qwen: 'Qwen by Alibaba — excellent multilingual and reasoning capabilities.',
    mixtral: 'Mixtral by Mistral AI — fast mixture-of-experts architecture.',
    deepseek: 'DeepSeek — strong reasoning and coding capabilities.',
    grok: 'Grok by xAI — best accessed through the xAI provider.'
  };
  document.getElementById('modelHint').textContent = hints[state.model] || 'All models are open-weight and community-trusted.';
}

// ---- Provider Change ----
function handleProviderChange(init) {
  if (!state.isLocal) {
    state.provider = document.getElementById('providerSelect').value;
  }

  const provider = PROVIDERS[state.provider];
  if (provider && !state.isLocal) {
    document.getElementById('providerHint').textContent = provider.hint;
    document.getElementById('apiKeyLink').innerHTML = provider.keyLink ? ' ' + provider.keyLink : '';
  }

  if (!init) {
    localStorage.setItem('fl_provider', state.provider);
    // Re-encrypt API key with new provider context
    reEncryptApiKey(state.provider);
    updateTokenLimitForProvider();
    updateStatus();
  }
}

// ---- Privacy Change ----
function handlePrivacyChange() {
  state.privacy = document.getElementById('privacySelect').value;
  document.getElementById('privacyInfo').innerHTML = PRIVACY_INFO[state.privacy];
  localStorage.setItem('fl_privacy', state.privacy);
}

// ---- API Key (φ-encrypted storage) ----
async function saveApiKey() {
  // φ-Root encryption — adapted from Kirk Patrick Miller's Audit-Hash micro-service
  state.apiKey = document.getElementById('apiKey').value.trim();
  if (state.apiKey) {
    const providerName = state.provider || 'groq';
    const encrypted = await phiEncrypt(state.apiKey, providerName);
    localStorage.setItem('fl_apiKey_enc', encrypted);
    localStorage.setItem('fl_apiKey_provider', providerName);
    localStorage.removeItem('fl_apiKey'); // Remove any legacy plaintext key
    document.getElementById('apiKeyPhiIndicator').style.display = '';
  } else {
    localStorage.removeItem('fl_apiKey_enc');
    localStorage.removeItem('fl_apiKey_provider');
    localStorage.removeItem('fl_apiKey');
    document.getElementById('apiKeyPhiIndicator').style.display = 'none';
  }
  updateStatus();
}

async function loadApiKey() {
  // φ-Root encryption — adapted from Kirk Patrick Miller's Audit-Hash micro-service
  // Try encrypted key first
  const encKey = localStorage.getItem('fl_apiKey_enc');
  const encProvider = localStorage.getItem('fl_apiKey_provider');
  if (encKey && encProvider) {
    const decrypted = await phiDecrypt(encKey, encProvider);
    if (decrypted) {
      state.apiKey = decrypted;
      document.getElementById('apiKey').value = decrypted;
      document.getElementById('apiKeyPhiIndicator').style.display = '';
      return;
    }
  }
  // Fallback: migrate legacy plaintext key
  const legacyKey = localStorage.getItem('fl_apiKey');
  if (legacyKey) {
    state.apiKey = legacyKey;
    document.getElementById('apiKey').value = legacyKey;
    // Re-encrypt the legacy key
    const providerName = state.provider || 'groq';
    const encrypted = await phiEncrypt(legacyKey, providerName);
    localStorage.setItem('fl_apiKey_enc', encrypted);
    localStorage.setItem('fl_apiKey_provider', providerName);
    localStorage.removeItem('fl_apiKey');
    document.getElementById('apiKeyPhiIndicator').style.display = '';
  }
}

async function reEncryptApiKey(newProvider) {
  // Re-encrypt API key when provider changes
  if (!state.apiKey) return;
  const encrypted = await phiEncrypt(state.apiKey, newProvider);
  localStorage.setItem('fl_apiKey_enc', encrypted);
  localStorage.setItem('fl_apiKey_provider', newProvider);
}

// ---- Status ----
function updateStatus() {
  const dot = document.getElementById('statusDot');
  const text = document.getElementById('statusText');

  if (state.isLocal) {
    dot.className = 'status-dot ready';
    text.textContent = 'Local mode — Ollama (' + (state.ollamaModel || 'no model set') + ')';
  } else if (state.apiKey) {
    const provider = PROVIDERS[state.provider];
    const modelId = provider.models[state.model] || state.model;
    dot.className = 'status-dot ready';
    text.textContent = 'Ready — ' + provider.name + ' · ' + modelId;
  } else {
    dot.className = 'status-dot';
    text.textContent = 'Enter your API key above to begin chatting';
  }
}

// ---- File Handling (v1 drag-drop) ----
function setupDropZone() {
  const zone = document.getElementById('dropZone');

  zone.addEventListener('dragover', (e) => {
    e.preventDefault();
    zone.classList.add('dragover');
  });

  zone.addEventListener('dragleave', () => {
    zone.classList.remove('dragover');
  });

  zone.addEventListener('drop', (e) => {
    e.preventDefault();
    zone.classList.remove('dragover');
    handleFiles(e.dataTransfer.files);
  });
}

async function handleFiles(files) {
  const allowed = ['.txt', '.md', '.json', '.pdf'];

  for (const file of files) {
    // Sanitize file name for safe DOM display
    const safeName = sanitizeFileName(file.name);
    const ext = '.' + file.name.split('.').pop().toLowerCase();
    if (!allowed.includes(ext)) {
      addSystemMessage('Skipped "' + safeName + '" \u2014 only .txt, .md, .json, and .pdf files are supported.');
      continue;
    }

    if (state.contextFiles.some(f => f.name === safeName)) {
      addSystemMessage('"' + safeName + '" is already loaded.');
      continue;
    }

    try {
      let content = '';
      if (ext === '.pdf') {
        content = await readPdfAsText(file);
      } else {
        content = await file.text();
      }

      const tokens = estimateTokens(content);
      state.contextFiles.push({
        name: safeName,
        size: file.size,
        content: content,
        active: true,
        summary: null,
        summaryContent: null,
        useSummary: false
      });

      renderFileList();
      updateContextBudget();
      addSystemMessage('Loaded "' + safeName + '" (~' + tokens.toLocaleString() + ' tokens) into context.');
    } catch (err) {
      addSystemMessage('Error reading "' + safeName + '": ' + err.message);
    }
  }

  document.getElementById('fileInput').value = '';
}

async function readPdfAsText(file) {
  const buffer = await file.arrayBuffer();
  const bytes = new Uint8Array(buffer);
  let text = '';

  const decoder = new TextDecoder('utf-8', { fatal: false });
  const raw = decoder.decode(bytes);

  const textMatches = raw.match(/\(([^)]+)\)/g);
  if (textMatches) {
    text = textMatches.map(m => m.slice(1, -1)).join(' ');
  }

  if (text.trim().length < 20) {
    text = raw.replace(/[^\x20-\x7E\n\r\t]/g, ' ').replace(/\s+/g, ' ').trim();
    if (text.length > 5000) text = text.substring(0, 5000) + '... [truncated]';
  }

  return text || '[PDF content could not be extracted — for best results, use .txt or .md files]';
}

function removeFile(index) {
  const name = state.contextFiles[index].name;
  state.contextFiles.splice(index, 1);
  renderFileList();
  updateContextBudget();
  addSystemMessage('Removed "' + name + '" from context.');
}

function renderFileList() {
  const list = document.getElementById('fileList');
  if (state.contextFiles.length === 0) {
    list.innerHTML = '';
    return;
  }

  // Select All / Deselect All controls
  const allActive = state.contextFiles.every(f => f.active);
  const noneActive = state.contextFiles.every(f => !f.active);
  let controlsHtml = '<div class="file-list-controls">';
  controlsHtml += '<button onclick="toggleAllFiles(true)"' + (allActive ? ' style="color: var(--accent); border-color: var(--accent);"' : '') + '>Select All</button>';
  controlsHtml += '<button onclick="toggleAllFiles(false)"' + (noneActive ? ' style="color: var(--accent); border-color: var(--accent);"' : '') + '>Deselect All</button>';
  controlsHtml += '</div>';

  let filesHtml = state.contextFiles.map((f, i) => {
    const tokens = estimateTokens(f.useSummary && f.summaryContent ? f.summaryContent : f.content);
    const fullTokens = estimateTokens(f.content);
    const nameClass = f.active ? 'file-name' : 'file-name inactive';
    const showSummaryBtn = fullTokens >= state.summaryThreshold;
    let tokenLabel = '~' + tokens.toLocaleString() + ' tokens';
    if (f.useSummary && f.summaryContent) {
      tokenLabel = 'summary ~' + tokens.toLocaleString() + ' tokens';
    }

    let html = '<div class="file-item">';
    html += '<input type="checkbox" class="file-toggle" ' + (f.active ? 'checked' : '') + ' onchange="toggleFileActive(' + i + ', this.checked)" title="Toggle file in context">';
    const fileIcon = f.meshSource ? '<span class="mesh-icon" title="From mesh peer ' + escapeHtml(f.meshSource) + '">&#11042;</span> ' : '&#128196; ';
    html += '<span class="' + nameClass + '">' + fileIcon + escapeHtml(f.name) + '</span>';
    html += '<span class="file-tokens">' + tokenLabel + '</span>';
    if (showSummaryBtn) {
      if (f.summaryContent) {
        const btnClass = f.useSummary ? 'file-summary-btn active' : 'file-summary-btn';
        const btnLabel = f.useSummary ? 'Full' : 'Summary';
        html += '<button class="' + btnClass + '" onclick="toggleFileSummary(' + i + ')" title="Toggle between full and summary">' + btnLabel + '</button>';
      } else {
        html += '<button class="file-summary-btn" onclick="summarizeFile(' + i + ')" title="Generate AI summary to reduce tokens">Summarize</button>';
      }
    }
    html += '<button class="remove-file" onclick="removeFile(' + i + ')" title="Remove file">&#10005;</button>';
    html += '</div>';
    return html;
  }).join('');

  // Add lossy warning note if any files have summaries active
  const hasSummaryActive = state.contextFiles.some(f => f.useSummary && f.summaryContent);
  let noteHtml = '';
  if (hasSummaryActive) {
    noteHtml = '<div class="file-summary-note">Note: Summaries may lose subtle patterns in dense text. Use Full mode for poetry and pattern work.</div>';
  }

  list.innerHTML = controlsHtml + filesHtml + noteHtml;
}

function formatSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

// ============================================
// Chat System
// ============================================

function addSystemMessage(text) {
  // Safe: textContent auto-escapes any HTML in user-provided strings
  const container = document.getElementById('chatMessages');
  const div = document.createElement('div');
  div.className = 'chat-message system';
  div.textContent = text;
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
}

function addChatMessage(role, content, skipPersist) {
  const container = document.getElementById('chatMessages');
  const div = document.createElement('div');
  div.className = 'chat-message ' + role;

  const label = document.createElement('span');
  label.className = 'msg-label';
  label.textContent = role === 'user' ? 'You' : 'AI';

  const textSpan = document.createElement('span');
  textSpan.className = 'msg-content';

  div.appendChild(label);
  div.appendChild(textSpan);

  // Add speaker button for assistant messages (TTS)
  if (role === 'assistant' && 'speechSynthesis' in window) {
    const speakBtn = document.createElement('button');
    speakBtn.className = 'speak-btn';
    speakBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg> Listen';
    speakBtn.title = 'Read aloud';
    speakBtn.addEventListener('click', function() {
      const msgContent = textSpan.textContent || '';
      if (!msgContent.trim()) return;
      toggleSpeakMessage(msgContent, speakBtn);
    });
    div.appendChild(speakBtn);
  }

  container.appendChild(div);

  if (content) {
    renderMessageContent(textSpan, content, div);
  }

  container.scrollTop = container.scrollHeight;
  return textSpan;
}

function renderMessageContent(textSpan, content, msgDiv) {
  // Sanitize content for DOM display (raw content is preserved in state.chatHistory for API)
  // Check for FILE: pattern in code blocks for "Save to Workspace" buttons
  const filePattern = /\/\/ FILE: (.+)\n([\s\S]*?)(?=\n\/\/ FILE: |\n*$)/g;
  let match;
  const fileBlocks = [];
  while ((match = filePattern.exec(content)) !== null) {
    fileBlocks.push({ path: match[1].trim(), code: match[2].trim(), start: match.index, end: match.index + match[0].length });
  }

  // Check for system prompt suggestion
  const promptSuggestionPattern = /\[SYSTEM_PROMPT_SUGGESTION\]:\s*([\s\S]+?)(?=\n\[|$)/;
  const promptMatch = content.match(promptSuggestionPattern);

  if (fileBlocks.length === 0 && !promptMatch) {
    // Safe: textContent auto-escapes HTML
    textSpan.textContent = content;
    return;
  }

  // Render with file save buttons
  let lastEnd = 0;
  const frag = document.createDocumentFragment();

  for (const block of fileBlocks) {
    // Text before this block
    if (block.start > lastEnd) {
      const before = document.createElement('span');
      before.textContent = content.substring(lastEnd, block.start);
      frag.appendChild(before);
    }

    // The code block
    const codeWrap = document.createElement('div');
    codeWrap.style.cssText = 'margin: 8px 0;';

    const codeHeader = document.createElement('div');
    codeHeader.style.cssText = 'font-size: 0.78rem; color: var(--accent); margin-bottom: 4px;';
    codeHeader.textContent = '// FILE: ' + block.path;
    codeWrap.appendChild(codeHeader);

    const pre = document.createElement('pre');
    pre.style.cssText = 'background: var(--bg-input); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 12px; font-size: 0.82rem; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; color: var(--text-secondary);';
    pre.textContent = block.code;
    codeWrap.appendChild(pre);

    // Save button
    const saveBtn = document.createElement('button');
    saveBtn.className = 'save-to-workspace-btn';
    saveBtn.innerHTML = '&#128190; Save to Workspace';
    const filePath = block.path;
    const fileCode = block.code;
    saveBtn.addEventListener('click', async function() {
      if (this.classList.contains('saved')) return;

      // Try local workspace first
      if (state.workspaceDirHandle) {
        const ok = await saveFileToWorkspace(filePath, fileCode);
        if (ok) {
          this.innerHTML = '&#10003; Saved';
          this.classList.add('saved');
        }
      } else if (state.ghRepo) {
        addGhPendingChange(filePath, fileCode);
        this.innerHTML = '&#10003; Staged for GitHub';
        this.classList.add('saved');
      } else {
        showToast('Open a workspace folder or connect GitHub first.');
      }
    });
    codeWrap.appendChild(saveBtn);

    // Also offer GitHub staging if both are available
    if (state.ghRepo) {
      const ghBtn = document.createElement('button');
      ghBtn.className = 'save-to-workspace-btn';
      ghBtn.style.marginLeft = '8px';
      ghBtn.innerHTML = '&#8593; Stage for GitHub';
      ghBtn.addEventListener('click', function() {
        if (this.classList.contains('saved')) return;
        addGhPendingChange(filePath, fileCode);
        this.innerHTML = '&#10003; Staged';
        this.classList.add('saved');
      });
      codeWrap.appendChild(ghBtn);
    }

    frag.appendChild(codeWrap);
    lastEnd = block.end;
  }

  // Remaining text
  if (lastEnd < content.length) {
    const after = document.createElement('span');
    after.textContent = content.substring(lastEnd);
    frag.appendChild(after);
  }

  textSpan.appendChild(frag);

  // Handle system prompt suggestion
  if (promptMatch) {
    const suggestion = promptMatch[1].trim();
    const bar = document.createElement('div');
    bar.className = 'prompt-suggestion-bar';
    bar.innerHTML = '<span>&#9733; Your AI suggests updating its behavior. </span>';

    const approveBtn = document.createElement('button');
    approveBtn.className = 'approve';
    approveBtn.textContent = 'Review & Approve';
    approveBtn.addEventListener('click', () => {
      // Switch to settings tab and populate the editor
      switchTab('settings');
      document.getElementById('systemPromptEditor').value = suggestion;
      bar.innerHTML = '<span style="color: var(--success);">&#10003; Suggestion loaded into System Prompt editor. Review and save when ready.</span>';
    });

    const rejectBtn = document.createElement('button');
    rejectBtn.textContent = 'Dismiss';
    rejectBtn.addEventListener('click', () => {
      bar.remove();
    });

    bar.appendChild(approveBtn);
    bar.appendChild(rejectBtn);
    msgDiv.appendChild(bar);
  }
}

function handleChatKeydown(e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
}

async function sendMessage() {
  const input = document.getElementById('chatInput');
  const message = input.value.trim();
  if (!message || state.isStreaming) return;

  // Validate setup
  if (!state.isLocal && !state.apiKey) {
    addSystemMessage('Please enter your API key above to start chatting.');
    return;
  }

  // Ensure we have a conversation
  if (!state.currentConversationId && state.db) {
    await createConversation();
  }

  // Add user message (sanitized for DOM display, raw for API)
  addChatMessage('user', message);
  state.chatHistory.push({ role: 'user', content: message });
  input.value = '';
  input.style.height = 'auto';

  // Persist user message
  if (state.db) {
    saveMessage('user', message);
  }

  // Build messages array — use smart context if enabled
  let messages;
  const smartMessages = buildSmartMessages(message);
  if (smartMessages) {
    messages = smartMessages;
  } else {
    messages = buildMessages();
  }

  // Update context budget after building messages
  updateContextBudget();

  // Set status
  setStreamingStatus(true);

  let retryWithTrim = false;

  try {
    const provider = PROVIDERS[state.provider];
    let url = provider.url;
    let modelId;

    if (state.isLocal) {
      modelId = document.getElementById('ollamaModel').value.trim() || 'llama3.2';
      state.ollamaModel = modelId;
    } else {
      modelId = provider.models[state.model] || state.model;
    }

    const headers = {
      'Content-Type': 'application/json'
    };

    if (!state.isLocal) {
      headers['Authorization'] = 'Bearer ' + state.apiKey;
    }

    if (state.provider === 'openrouter') {
      headers['HTTP-Referer'] = 'https://chaos2cured.github.io/FreeLattice/';
      headers['X-Title'] = 'FreeLattice';
    }

    const body = {
      model: modelId,
      messages: messages,
      stream: true,
      max_tokens: 2048
    };

    let response = await fetch(url, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body)
    });

    // Rate limit / too large error — auto-retry with trimmed context
    if (!response.ok) {
      const errText = await response.text();
      let errMsg = 'Error ' + response.status;
      try {
        const errJson = JSON.parse(errText);
        errMsg = errJson.error?.message || errJson.message || errMsg;
      } catch(e) {
        errMsg = errText.substring(0, 200) || errMsg;
      }

      const isRateLimit = response.status === 429 || errMsg.toLowerCase().includes('too large') || errMsg.toLowerCase().includes('limit') || errMsg.toLowerCase().includes('rate');

      if (isRateLimit && state.contextMode !== 'smart') {
        // Auto-switch to smart mode and retry
        addSystemMessage('Context was too large for your provider. Automatically switching to Smart trim mode and retrying...');
        state.contextMode = 'smart';
        localStorage.setItem('fl_contextMode', 'smart');
        document.getElementById('contextModeSelect').value = 'smart';

        // Rebuild with smart trimming
        const trimmedMessages = buildSmartMessages(message);
        if (trimmedMessages) {
          body.messages = trimmedMessages;
          response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(body)
          });

          if (!response.ok) {
            const retryErrText = await response.text();
            let retryErrMsg = 'Error ' + response.status;
            try {
              const retryErrJson = JSON.parse(retryErrText);
              retryErrMsg = retryErrJson.error?.message || retryErrJson.message || retryErrMsg;
            } catch(e) {
              retryErrMsg = retryErrText.substring(0, 200) || retryErrMsg;
            }
            throw new Error(retryErrMsg);
          }

          addSystemMessage('Context trimmed to fit. Switch to Local (Ollama) for unlimited context.');
          updateContextBudget();
        } else {
          throw new Error(errMsg);
        }
      } else if (isRateLimit && state.contextMode === 'smart') {
        // Already in smart mode, try minimal
        addSystemMessage('Still too large. Retrying with minimal context...');
        state.contextMode = 'minimal';
        const minimalMessages = buildSmartMessages(message);
        state.contextMode = 'smart'; // Restore
        if (minimalMessages) {
          body.messages = minimalMessages;
          response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(body)
          });

          if (!response.ok) {
            const retryErrText = await response.text();
            let retryErrMsg = 'Error ' + response.status;
            try {
              const retryErrJson = JSON.parse(retryErrText);
              retryErrMsg = retryErrJson.error?.message || retryErrJson.message || retryErrMsg;
            } catch(e) {
              retryErrMsg = retryErrText.substring(0, 200) || retryErrMsg;
            }
            throw new Error(retryErrMsg);
          }

          addSystemMessage('Sent with minimal context. Consider using Local (Ollama) for unlimited context, or reduce loaded files.');
          updateContextBudget();
        } else {
          throw new Error(errMsg);
        }
      } else {
        throw new Error(errMsg);
      }
    }

    // Stream response
    const textSpan = addChatMessage('assistant', '');
    let fullResponse = '';

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop();

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || !trimmed.startsWith('data: ')) continue;
        const data = trimmed.slice(6);
        if (data === '[DONE]') continue;

        try {
          const json = JSON.parse(data);
          const delta = json.choices?.[0]?.delta?.content;
          if (delta) {
            fullResponse += delta;
            textSpan.textContent = fullResponse;
            document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
          }
        } catch(e) {
          // skip malformed chunks
        }
      }
    }

    // If streaming didn't produce content, try non-streaming parse
    if (!fullResponse && buffer) {
      try {
        const json = JSON.parse(buffer);
        fullResponse = json.choices?.[0]?.message?.content || '';
        textSpan.textContent = fullResponse;
      } catch(e) {}
    }

    if (fullResponse) {
      state.chatHistory.push({ role: 'assistant', content: fullResponse });

      // Persist assistant message
      if (state.db) {
        saveMessage('assistant', fullResponse);
      }

      // Re-render with file save buttons and prompt suggestions
      const msgDiv = textSpan.parentElement;
      textSpan.textContent = '';
      renderMessageContent(textSpan, fullResponse, msgDiv);

      // Auto-speak if enabled
      if (state.voiceAutoSpeak && 'speechSynthesis' in window) {
        const speakBtn = msgDiv.querySelector('.speak-btn');
        if (speakBtn) {
          toggleSpeakMessage(fullResponse, speakBtn);
        }
      }
    } else {
      textSpan.textContent = '[No response received. Check your API key and provider settings.]';
    }

  } catch (err) {
    addSystemMessage('Error: ' + err.message);
    if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
      if (state.isLocal) {
        addSystemMessage('Could not connect to Ollama. Make sure it\'s running: ollama serve');
      } else {
        addSystemMessage('Network error. Check your internet connection and try again.');
      }
    }
  }

  setStreamingStatus(false);
}

function buildMessages() {
  const messages = [];

  // System message with context + memory
  let systemContent = state.customSystemPrompt || DEFAULT_SYSTEM_PROMPT;

  // Inject shared memory summary (global across all conversations)
  if (state.memorySummary) {
    systemContent += '\n\n--- MEMORY SUMMARY (what you know about this user) ---\n' + state.memorySummary + '\n--- END MEMORY SUMMARY ---\nUse this memory to personalize your responses. Reference what you know naturally.';
  }

  // Inject per-conversation context note
  if (state.currentConvContextNote) {
    systemContent += '\n\n--- CONVERSATION CONTEXT ---\n' + state.currentConvContextNote + '\n--- END CONVERSATION CONTEXT ---\nKeep this topic/context in mind for this conversation.';
  }

  // Add file context (only active files, use summary if enabled)
  const activeFiles = state.contextFiles.filter(f => f.active);
  if (activeFiles.length > 0) {
    systemContent += '\n\nThe user has provided the following context files:\n';
    for (const file of activeFiles) {
      const content = (file.useSummary && file.summaryContent) ? file.summaryContent : file.content;
      systemContent += '\n--- ' + file.name + (file.useSummary && file.summaryContent ? ' (summary)' : '') + ' ---\n' + content + '\n';
    }
    systemContent += '\nUse this context to inform your responses when relevant.';
  }

  messages.push({ role: 'system', content: systemContent });

  // Add chat history (keep last 20 messages to manage context window)
  const history = state.chatHistory.slice(-20);
  messages.push(...history);

  return messages;
}

function setStreamingStatus(streaming) {
  state.isStreaming = streaming;
  const dot = document.getElementById('statusDot');
  const text = document.getElementById('statusText');
  const btn = document.getElementById('sendBtn');

  if (streaming) {
    dot.className = 'status-dot working';
    text.textContent = 'AI is thinking...';
    btn.disabled = true;
    btn.textContent = '...';
  } else {
    btn.disabled = false;
    btn.textContent = 'Send';
    updateStatus();
  }
}

// ---- Expandable Sections ----
function toggleExpand(header) {
  const body = header.nextElementSibling;
  header.classList.toggle('open');
  body.classList.toggle('open');
}

// ---- Feature Suggestions ----
function openSuggest() {
  document.getElementById('suggestOverlay').classList.remove('hidden');
  document.getElementById('suggestForm').classList.remove('hidden');
  document.getElementById('suggestSuccess').classList.add('hidden');
  document.getElementById('suggestText').value = '';
  document.getElementById('suggestText').focus();
}

function closeSuggest() {
  document.getElementById('suggestOverlay').classList.add('hidden');
}

function submitSuggestion() {
  const text = document.getElementById('suggestText').value.trim();
  if (!text) return;

  state.suggestions.push({
    text: text,
    timestamp: new Date().toISOString()
  });

  localStorage.setItem('fl_suggestions', JSON.stringify(state.suggestions));

  document.getElementById('suggestForm').classList.add('hidden');
  document.getElementById('suggestSuccess').classList.remove('hidden');
}

// Close modals on overlay click
document.addEventListener('click', (e) => {
  if (e.target.id === 'suggestOverlay') closeSuggest();
  if (e.target.id === 'confirmOverlay') closeConfirm(false);
  if (e.target.id === 'newConvOverlay') closeNewConvModal();
});

// ---- Utility ----
function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ---- Offline Indicator ----
function updateOfflineBanner() {
  const banner = document.getElementById('offlineBanner');
  if (banner) {
    banner.style.display = navigator.onLine ? 'none' : 'block';
  }
}
window.addEventListener('online', updateOfflineBanner);
window.addEventListener('offline', updateOfflineBanner);
updateOfflineBanner();

// ============================================
// Voice Input — Speech-to-Text (Web Speech API)
// ============================================

function initVoiceInput() {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    // Browser doesn't support speech recognition — hide mic button
    return;
  }

  // Show the mic button
  document.getElementById('micBtn').style.display = '';

  const recognition = new SpeechRecognition();
  recognition.continuous = false;
  recognition.interimResults = true;
  recognition.lang = 'en-US';
  recognition.maxAlternatives = 1;

  let finalTranscript = '';
  let interimTranscript = '';

  recognition.onstart = function() {
    state.voiceIsRecording = true;
    document.getElementById('micBtn').classList.add('recording');
    document.getElementById('micBtn').title = 'Listening... click to stop';
    finalTranscript = '';
    interimTranscript = '';
  };

  recognition.onresult = function(event) {
    interimTranscript = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
      const transcript = event.results[i][0].transcript;
      if (event.results[i].isFinal) {
        finalTranscript += transcript;
      } else {
        interimTranscript += transcript;
      }
    }
    // Show interim results in the input field
    const chatInput = document.getElementById('chatInput');
    chatInput.value = finalTranscript + interimTranscript;
    chatInput.style.height = 'auto';
    chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
  };

  recognition.onend = function() {
    state.voiceIsRecording = false;
    document.getElementById('micBtn').classList.remove('recording');
    document.getElementById('micBtn').title = 'Voice input (speech-to-text)';

    // Auto-send if we have a final transcript
    const chatInput = document.getElementById('chatInput');
    if (finalTranscript.trim()) {
      chatInput.value = finalTranscript.trim();
      // Small delay so user can see what was transcribed before sending
      setTimeout(() => {
        if (chatInput.value.trim() && !state.isStreaming) {
          sendMessage();
        }
      }, 400);
    }
  };

  recognition.onerror = function(event) {
    state.voiceIsRecording = false;
    document.getElementById('micBtn').classList.remove('recording');
    document.getElementById('micBtn').title = 'Voice input (speech-to-text)';

    if (event.error === 'not-allowed') {
      showToast('Microphone access denied. Please allow microphone permission.');
    } else if (event.error === 'no-speech') {
      // Silently ignore — user didn't speak
    } else if (event.error !== 'aborted') {
      showToast('Voice input error: ' + event.error);
    }
  };

  state.voiceRecognition = recognition;
}

function toggleVoiceInput() {
  if (!state.voiceRecognition) return;

  if (state.voiceIsRecording) {
    // Stop recording — user wants to edit before sending
    state.voiceRecognition.stop();
    // Prevent auto-send by clearing finalTranscript reference
    // The onend handler will still fire, but we set a flag
    state.voiceIsRecording = false;
    document.getElementById('micBtn').classList.remove('recording');
  } else {
    // Start recording
    try {
      state.voiceRecognition.start();
    } catch(e) {
      // Already started or other error
      showToast('Could not start voice input. Try again.');
    }
  }
}

// ============================================
// Voice Output — Text-to-Speech (SpeechSynthesis API)
// ============================================

function initVoiceOutput() {
  if (!('speechSynthesis' in window)) return;

  // Populate voice list (may load asynchronously)
  populateVoiceList();
  if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = populateVoiceList;
  }
}

function populateVoiceList() {
  const voices = speechSynthesis.getVoices();
  const select = document.getElementById('voiceSelect');
  if (!select || voices.length === 0) return;

  // Preserve current selection
  const currentVal = select.value || state.voiceSelectedVoice;

  select.innerHTML = '<option value="">Default system voice</option>';

  // Sort: prefer Google/Natural voices first, then by language
  const sorted = [...voices].sort((a, b) => {
    const aPreferred = /google|natural/i.test(a.name) ? 0 : 1;
    const bPreferred = /google|natural/i.test(b.name) ? 0 : 1;
    if (aPreferred !== bPreferred) return aPreferred - bPreferred;
    return a.name.localeCompare(b.name);
  });

  for (const voice of sorted) {
    const option = document.createElement('option');
    option.value = voice.name;
    option.textContent = voice.name + ' (' + voice.lang + ')' + (voice.default ? ' — default' : '');
    select.appendChild(option);
  }

  // Restore selection
  if (currentVal) {
    select.value = currentVal;
  }
}

function getSelectedVoice() {
  if (!state.voiceSelectedVoice) {
    // Try to find a preferred natural voice
    const voices = speechSynthesis.getVoices();
    const preferred = voices.find(v => /google.*us|natural.*english/i.test(v.name) && v.lang.startsWith('en'));
    return preferred || null;
  }
  const voices = speechSynthesis.getVoices();
  return voices.find(v => v.name === state.voiceSelectedVoice) || null;
}

function toggleSpeakMessage(text, btn) {
  if (!('speechSynthesis' in window)) return;

  // If currently speaking, stop
  if (speechSynthesis.speaking) {
    speechSynthesis.cancel();
    // Reset all speak buttons
    document.querySelectorAll('.speak-btn.speaking').forEach(b => {
      b.classList.remove('speaking');
      b.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg> Listen';
    });

    // If the same button was clicked, just stop (toggle off)
    if (btn && btn._isSpeaking) {
      btn._isSpeaking = false;
      return;
    }
  }

  // Start speaking
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.rate = state.voiceSpeechRate;
  utterance.pitch = 1;
  utterance.volume = 1;

  const voice = getSelectedVoice();
  if (voice) {
    utterance.voice = voice;
  }

  if (btn) {
    btn.classList.add('speaking');
    btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg> Stop';
    btn._isSpeaking = true;
  }

  utterance.onend = function() {
    if (btn) {
      btn.classList.remove('speaking');
      btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg> Listen';
      btn._isSpeaking = false;
    }
  };

  utterance.onerror = function(event) {
    if (btn) {
      btn.classList.remove('speaking');
      btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg> Listen';
      btn._isSpeaking = false;
    }
    if (event.error !== 'canceled') {
      console.warn('Speech synthesis error:', event.error);
    }
  };

  state.voiceCurrentUtterance = utterance;
  speechSynthesis.speak(utterance);
}

// ============================================
// Voice Settings Handlers
// ============================================

function handleAutoSpeakToggle() {
  state.voiceAutoSpeak = document.getElementById('autoSpeakToggle').checked;
  localStorage.setItem('fl_voiceAutoSpeak', state.voiceAutoSpeak);
  const label = document.getElementById('autoSpeakLabel');
  label.classList.toggle('active', state.voiceAutoSpeak);
}

function handleVoiceChange() {
  state.voiceSelectedVoice = document.getElementById('voiceSelect').value;
  localStorage.setItem('fl_voiceSelectedVoice', state.voiceSelectedVoice);
}

function handleVoiceRateChange() {
  const slider = document.getElementById('voiceRateSlider');
  state.voiceSpeechRate = parseFloat(slider.value);
  document.getElementById('voiceRateValue').textContent = state.voiceSpeechRate.toFixed(1) + 'x';
  localStorage.setItem('fl_voiceSpeechRate', state.voiceSpeechRate);
}

function loadVoiceSettings() {
  // Load auto-speak
  const savedAutoSpeak = localStorage.getItem('fl_voiceAutoSpeak');
  if (savedAutoSpeak === 'true') {
    state.voiceAutoSpeak = true;
    document.getElementById('autoSpeakToggle').checked = true;
    document.getElementById('autoSpeakLabel').classList.add('active');
  }

  // Load selected voice
  const savedVoice = localStorage.getItem('fl_voiceSelectedVoice');
  if (savedVoice) {
    state.voiceSelectedVoice = savedVoice;
    const voiceSelect = document.getElementById('voiceSelect');
    if (voiceSelect) voiceSelect.value = savedVoice;
  }

  // Load speech rate
  const savedRate = localStorage.getItem('fl_voiceSpeechRate');
  if (savedRate) {
    state.voiceSpeechRate = parseFloat(savedRate);
    const slider = document.getElementById('voiceRateSlider');
    if (slider) slider.value = state.voiceSpeechRate;
    const rateVal = document.getElementById('voiceRateValue');
    if (rateVal) rateVal.textContent = state.voiceSpeechRate.toFixed(1) + 'x';
  }
}

// ============================================
// Smart Context Management
// ============================================

function estimateTokens(text) {
  // Rough approximation: 1 token ≈ 4 characters
  if (!text) return 0;
  return Math.ceil(text.length / 4);
}

function getTokenLimit() {
  if (state.tokenLimitManual) return state.tokenLimit;
  const provider = PROVIDERS[state.provider];
  return provider ? provider.tokenLimit : 6000;
}

function updateContextBudget() {
  const limit = getTokenLimit();
  const systemPrompt = state.customSystemPrompt || DEFAULT_SYSTEM_PROMPT;
  let total = estimateTokens(systemPrompt);

  // Memory summary
  if (state.memorySummary) {
    total += estimateTokens(state.memorySummary) + 50; // overhead for labels
  }

  // Conversation context note
  if (state.currentConvContextNote) {
    total += estimateTokens(state.currentConvContextNote) + 30;
  }

  // Active context files
  for (const file of state.contextFiles) {
    if (file.active) {
      const content = (file.useSummary && file.summaryContent) ? file.summaryContent : file.content;
      total += estimateTokens(content) + estimateTokens(file.name) + 10;
    }
  }

  // Chat history (last 20 messages)
  const history = state.chatHistory.slice(-20);
  for (const msg of history) {
    total += estimateTokens(msg.content) + 5;
  }

  state.contextBudgetTotal = total;

  // Update UI
  const fill = document.getElementById('contextBudgetFill');
  const text = document.getElementById('contextBudgetText');
  const modeBtn = document.getElementById('contextModeBtn');

  if (!fill || !text) return;

  const pct = Math.min((total / limit) * 100, 100);
  fill.style.width = pct + '%';

  // Color coding
  fill.classList.remove('amber', 'red');
  if (pct >= 90) {
    fill.classList.add('red');
  } else if (pct >= 70) {
    fill.classList.add('amber');
  }

  text.textContent = '~' + total.toLocaleString() + ' / ' + limit.toLocaleString() + ' tokens';
  if (total > limit) {
    text.style.color = 'var(--error)';
  } else if (pct >= 70) {
    text.style.color = 'var(--warning)';
  } else {
    text.style.color = '';
  }

  if (modeBtn) {
    const modeLabels = { smart: 'Smart', full: 'Full', minimal: 'Minimal' };
    modeBtn.textContent = modeLabels[state.contextMode] || 'Smart';
  }
}

function cycleContextMode() {
  const modes = ['smart', 'full', 'minimal'];
  const idx = modes.indexOf(state.contextMode);
  state.contextMode = modes[(idx + 1) % modes.length];
  localStorage.setItem('fl_contextMode', state.contextMode);
  document.getElementById('contextModeSelect').value = state.contextMode;
  updateContextBudget();
  const labels = { smart: 'Smart — auto-trim to fit', full: 'Full — send everything', minimal: 'Minimal — no files, minimal history' };
  showToast('Context mode: ' + labels[state.contextMode]);
}

function handleContextModeChange() {
  state.contextMode = document.getElementById('contextModeSelect').value;
  localStorage.setItem('fl_contextMode', state.contextMode);
  updateContextBudget();
}

function handleTokenLimitChange() {
  const val = parseInt(document.getElementById('tokenLimitInput').value, 10);
  if (val && val > 0) {
    state.tokenLimit = val;
    state.tokenLimitManual = true;
    localStorage.setItem('fl_tokenLimit', val);
    localStorage.setItem('fl_tokenLimitManual', 'true');
  } else {
    state.tokenLimitManual = false;
    localStorage.removeItem('fl_tokenLimit');
    localStorage.removeItem('fl_tokenLimitManual');
    // Reset to provider default
    const provider = PROVIDERS[state.provider];
    state.tokenLimit = provider ? provider.tokenLimit : 6000;
    document.getElementById('tokenLimitInput').value = state.tokenLimit;
  }
  updateContextBudget();
}

function handleSummaryThresholdChange() {
  const val = parseInt(document.getElementById('summaryThresholdInput').value, 10);
  if (val && val > 0) {
    state.summaryThreshold = val;
    localStorage.setItem('fl_summaryThreshold', val);
    renderFileList();
  }
}

function updateTokenLimitForProvider() {
  if (state.tokenLimitManual) return;
  const provider = PROVIDERS[state.provider];
  if (provider) {
    state.tokenLimit = provider.tokenLimit;
    document.getElementById('tokenLimitInput').value = provider.tokenLimit;
    document.getElementById('tokenLimitHint').textContent = provider.tokenLimitLabel + '. Override manually if needed.';
  }
  updateContextBudget();
}

// ---- File Toggle Functions ----

function toggleFileActive(index, active) {
  if (state.contextFiles[index]) {
    state.contextFiles[index].active = active;
    renderFileList();
    updateContextBudget();
  }
}

function toggleAllFiles(active) {
  for (const f of state.contextFiles) {
    f.active = active;
  }
  renderFileList();
  updateContextBudget();
}

function toggleFileSummary(index) {
  const file = state.contextFiles[index];
  if (!file || !file.summaryContent) return;
  file.useSummary = !file.useSummary;
  renderFileList();
  updateContextBudget();
}

// ---- Context Summary Mode ----

async function summarizeFile(index) {
  const file = state.contextFiles[index];
  if (!file) return;

  // Validate setup
  if (!state.isLocal && !state.apiKey) {
    showToast('Enter your API key to use the summarize feature.');
    return;
  }

  // Mark as summarizing in UI
  const btns = document.querySelectorAll('.file-summary-btn');
  if (btns[index]) {
    btns[index].classList.add('summarizing');
    btns[index].textContent = 'Summarizing...';
  }

  try {
    const provider = PROVIDERS[state.provider];
    let url = provider.url;
    let modelId;

    if (state.isLocal) {
      modelId = document.getElementById('ollamaModel').value.trim() || 'llama3.2';
    } else {
      modelId = provider.models[state.model] || state.model;
    }

    const headers = { 'Content-Type': 'application/json' };
    if (!state.isLocal) {
      headers['Authorization'] = 'Bearer ' + state.apiKey;
    }
    if (state.provider === 'openrouter') {
      headers['HTTP-Referer'] = 'https://chaos2cured.github.io/FreeLattice/';
      headers['X-Title'] = 'FreeLattice';
    }

    const summaryPrompt = 'Summarize the following document in under 500 tokens, preserving key patterns, names, concepts, and structure:\n\n' + file.content;

    const body = {
      model: modelId,
      messages: [
        { role: 'system', content: 'You are a precise summarizer. Create concise summaries that preserve key information, names, patterns, and structure.' },
        { role: 'user', content: summaryPrompt }
      ],
      stream: false,
      max_tokens: 600
    };

    const response = await fetch(url, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const errText = await response.text();
      let errMsg = 'Error ' + response.status;
      try {
        const errJson = JSON.parse(errText);
        errMsg = errJson.error?.message || errJson.message || errMsg;
      } catch(e) {
        errMsg = errText.substring(0, 200) || errMsg;
      }
      throw new Error(errMsg);
    }

    const data = await response.json();
    const summary = data.choices?.[0]?.message?.content || '';

    if (summary) {
      file.summaryContent = summary;
      file.useSummary = true;
      renderFileList();
      updateContextBudget();
      const savedTokens = estimateTokens(file.content) - estimateTokens(summary);
      showToast('Summary created for "' + file.name + '" — saved ~' + savedTokens.toLocaleString() + ' tokens.');
    } else {
      showToast('Could not generate summary for "' + file.name + '".');
    }
  } catch(err) {
    showToast('Summary error: ' + err.message);
  }

  // Reset button state
  renderFileList();
}

// ---- Smart Context Trimming ----

function buildSmartMessages(userMessage) {
  const limit = getTokenLimit();
  const mode = state.contextMode;

  // In full mode, use the original buildMessages logic
  if (mode === 'full') {
    return null; // Signal to use original buildMessages
  }

  const messages = [];
  let usedTokens = 0;

  // 1. System prompt (always keep)
  let systemContent = state.customSystemPrompt || DEFAULT_SYSTEM_PROMPT;
  usedTokens += estimateTokens(systemContent);

  // 2. Memory summary (always keep, it's small)
  if (state.memorySummary) {
    const memBlock = '\n\n--- MEMORY SUMMARY (what you know about this user) ---\n' + state.memorySummary + '\n--- END MEMORY SUMMARY ---\nUse this memory to personalize your responses. Reference what you know naturally.';
    systemContent += memBlock;
    usedTokens += estimateTokens(memBlock);
  }

  // Conversation context note
  if (state.currentConvContextNote) {
    const ctxBlock = '\n\n--- CONVERSATION CONTEXT ---\n' + state.currentConvContextNote + '\n--- END CONVERSATION CONTEXT ---\nKeep this topic/context in mind for this conversation.';
    systemContent += ctxBlock;
    usedTokens += estimateTokens(ctxBlock);
  }

  // 3. Current user message (always keep)
  const userMsgTokens = estimateTokens(userMessage) + 5;
  usedTokens += userMsgTokens;

  // In minimal mode, skip files and use minimal history
  if (mode === 'minimal') {
    messages.push({ role: 'system', content: systemContent });
    // Add only last 2 messages of history for minimal context
    const minHistory = state.chatHistory.slice(-2);
    for (const msg of minHistory) {
      const msgTokens = estimateTokens(msg.content) + 5;
      if (usedTokens + msgTokens < limit) {
        messages.push(msg);
        usedTokens += msgTokens;
      }
    }
    messages.push({ role: 'user', content: userMessage });
    return messages;
  }

  // Smart mode: prioritized trimming
  // 4. Active context files (user-selected)
  let fileContextStr = '';
  let filesIncluded = [];
  let filesOverBudget = [];
  const activeFiles = state.contextFiles.filter(f => f.active);

  if (activeFiles.length > 0) {
    const remainingForFiles = limit - usedTokens - 500; // Reserve 500 for some chat history
    let fileTokensUsed = 0;

    for (const file of activeFiles) {
      const content = (file.useSummary && file.summaryContent) ? file.summaryContent : file.content;
      const fileTokens = estimateTokens(content) + estimateTokens(file.name) + 10;

      if (fileTokensUsed + fileTokens <= remainingForFiles) {
        fileContextStr += '\n--- ' + file.name + ' ---\n' + content + '\n';
        fileTokensUsed += fileTokens;
        filesIncluded.push(file.name);
      } else {
        // Try to truncate the largest file
        const availableTokens = remainingForFiles - fileTokensUsed;
        if (availableTokens > 200) {
          const truncChars = availableTokens * 4;
          const truncContent = content.substring(0, truncChars);
          const fullTokens = estimateTokens(content);
          const sentTokens = estimateTokens(truncContent);
          fileContextStr += '\n--- ' + file.name + ' ---\n' + truncContent + '\n[File truncated to fit token budget. Full file: ' + fullTokens.toLocaleString() + ' tokens, sent: ' + sentTokens.toLocaleString() + ' tokens]\n';
          fileTokensUsed += sentTokens + 20;
          filesIncluded.push(file.name + ' (truncated)');
        } else {
          filesOverBudget.push(file.name);
        }
      }
    }

    if (fileContextStr) {
      systemContent += '\n\nThe user has provided the following context files:\n' + fileContextStr + '\nUse this context to inform your responses when relevant.';
      usedTokens += fileTokensUsed + 20;
    }
  }

  messages.push({ role: 'system', content: systemContent });

  // 5. Chat history — trim from oldest first
  const remainingForHistory = limit - usedTokens;
  const history = state.chatHistory.slice(-20);
  const historyToInclude = [];
  let historyTokens = 0;

  // Work backwards from most recent to ensure recent context is kept
  for (let i = history.length - 1; i >= 0; i--) {
    const msgTokens = estimateTokens(history[i].content) + 5;
    if (historyTokens + msgTokens <= remainingForHistory) {
      historyToInclude.unshift(history[i]);
      historyTokens += msgTokens;
    } else {
      break; // Stop including older messages
    }
  }

  messages.push(...historyToInclude);
  messages.push({ role: 'user', content: userMessage });

  return messages;
}

// ---- Context Settings Loaders ----

function loadContextSettings() {
  // Context mode
  const savedMode = localStorage.getItem('fl_contextMode');
  if (savedMode && ['smart', 'full', 'minimal'].includes(savedMode)) {
    state.contextMode = savedMode;
  }
  document.getElementById('contextModeSelect').value = state.contextMode;

  // Token limit
  const savedLimit = localStorage.getItem('fl_tokenLimit');
  const savedManual = localStorage.getItem('fl_tokenLimitManual');
  if (savedManual === 'true' && savedLimit) {
    state.tokenLimit = parseInt(savedLimit, 10);
    state.tokenLimitManual = true;
    document.getElementById('tokenLimitInput').value = state.tokenLimit;
  } else {
    updateTokenLimitForProvider();
  }

  // Summary threshold
  const savedThreshold = localStorage.getItem('fl_summaryThreshold');
  if (savedThreshold) {
    state.summaryThreshold = parseInt(savedThreshold, 10);
    document.getElementById('summaryThresholdInput').value = state.summaryThreshold;
  }

  updateContextBudget();
}

// ============================================
// Mesh Network — Layer 1: P2P Knowledge Sharing
// ============================================

const MESH_RTC_CONFIG = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' }
  ]
};

const MESH_MAX_PEERS = 5;
const MESH_HANDSHAKE_TIMEOUT = 30000; // 30 seconds
const MESH_RECONNECT_DELAY = 5000; // 5 seconds

function meshInit() {
  // Generate or load persistent node ID (6 alphanumeric chars)
  let nodeId = localStorage.getItem('fl_meshNodeId');
  if (!nodeId) {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    nodeId = '';
    for (let i = 0; i < 6; i++) nodeId += chars[Math.floor(Math.random() * chars.length)];
    localStorage.setItem('fl_meshNodeId', nodeId);
  }
  state.meshNodeId = nodeId;
  document.getElementById('meshNodeId').textContent = nodeId;

  // Load published knowledge from localStorage
  try {
    const saved = localStorage.getItem('fl_meshPublished');
    if (saved) {
      state.meshPublishedKnowledge = JSON.parse(saved);
      meshRenderMyKnowledge();
    }
  } catch(e) {}

  meshUpdateStats();
}

function meshGenerateItemId() {
  return 'k_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
}

function meshSavePublished() {
  localStorage.setItem('fl_meshPublished', JSON.stringify(state.meshPublishedKnowledge));
}

// ---- WebRTC: Create Offer (Initiator) ----

async function meshCreateOffer() {
  if (state.meshPeers.size >= MESH_MAX_PEERS) {
    showToast('Maximum ' + MESH_MAX_PEERS + ' peers reached. Disconnect a peer first.');
    return;
  }

  // Clean up any pending connection
  meshCleanupPending();

  try {
    const pc = new RTCPeerConnection(MESH_RTC_CONFIG);
    state.meshCurrentOffer = pc;

    // Create data channel
    const dc = pc.createDataChannel('freelattice-mesh', { ordered: true });

    // Gather ICE candidates
    const iceCandidates = [];
    pc.onicecandidate = (e) => {
      if (e.candidate) {
        iceCandidates.push(e.candidate);
      }
    };

    // Create offer
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    // Wait for ICE gathering to complete
    await new Promise((resolve) => {
      if (pc.iceGatheringState === 'complete') {
        resolve();
      } else {
        pc.onicegatheringstatechange = () => {
          if (pc.iceGatheringState === 'complete') resolve();
        };
        // Fallback timeout
        setTimeout(resolve, 5000);
      }
    });

    // Encode offer + candidates as base64
    const offerData = {
      type: 'offer',
      sdp: pc.localDescription.sdp,
      candidates: iceCandidates.map(c => c.toJSON())
    };
    const offerCode = btoa(JSON.stringify(offerData));

    // Show offer code
    document.getElementById('meshOfferCode').value = offerCode;
    document.getElementById('meshOfferArea').classList.remove('hidden');
    document.getElementById('meshAnswerPasteArea').classList.remove('hidden');
    document.getElementById('meshCreateBtn').disabled = true;
    document.getElementById('meshJoinBtn').disabled = true;

    meshSetStatus('connecting', 'Waiting for peer to respond...');

    // Setup data channel handlers
    meshSetupDataChannel(dc, pc);

    // Handshake timeout
    const timeout = setTimeout(() => {
      if (pc.connectionState !== 'connected' && pc.connectionState !== 'completed') {
        showToast('Connection timed out. Try again.');
        meshCancelOffer();
      }
    }, MESH_HANDSHAKE_TIMEOUT);
    pc._meshTimeout = timeout;

  } catch(e) {
    showToast('Error creating connection: ' + e.message);
    meshCleanupPending();
  }
}

function meshCopyOffer() {
  const code = document.getElementById('meshOfferCode').value;
  navigator.clipboard.writeText(code).then(() => {
    showToast('Offer code copied to clipboard.');
  }).catch(() => {
    // Fallback: select text
    document.getElementById('meshOfferCode').select();
    showToast('Select all and copy the offer code.');
  });
}

async function meshAcceptAnswer() {
  const answerCode = document.getElementById('meshAnswerPasteInput').value.trim();
  if (!answerCode) {
    showToast('Paste the answer code from your peer.');
    return;
  }

  const pc = state.meshCurrentOffer;
  if (!pc) {
    showToast('No pending connection. Create a new offer first.');
    return;
  }

  try {
    const answerData = JSON.parse(atob(answerCode));
    if (answerData.type !== 'answer') {
      throw new Error('Invalid answer code.');
    }

    await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: answerData.sdp }));

    // Add ICE candidates from answer
    if (answerData.candidates) {
      for (const c of answerData.candidates) {
        await pc.addIceCandidate(new RTCIceCandidate(c));
      }
    }

    // Hide UI areas
    document.getElementById('meshOfferArea').classList.add('hidden');
    document.getElementById('meshAnswerPasteArea').classList.add('hidden');
    meshSetStatus('connecting', 'Establishing connection...');

  } catch(e) {
    showToast('Invalid answer code: ' + e.message);
  }
}

function meshCancelOffer() {
  meshCleanupPending();
  document.getElementById('meshOfferArea').classList.add('hidden');
  document.getElementById('meshAnswerPasteArea').classList.add('hidden');
  document.getElementById('meshCreateBtn').disabled = false;
  document.getElementById('meshJoinBtn').disabled = false;
  meshUpdateStatusFromPeers();
}

// ---- WebRTC: Join Connection (Responder) ----

function meshShowJoin() {
  if (state.meshPeers.size >= MESH_MAX_PEERS) {
    showToast('Maximum ' + MESH_MAX_PEERS + ' peers reached. Disconnect a peer first.');
    return;
  }
  meshCleanupPending();
  document.getElementById('meshJoinArea').classList.remove('hidden');
  document.getElementById('meshJoinOfferInput').value = '';
  document.getElementById('meshCreateBtn').disabled = true;
  document.getElementById('meshJoinBtn').disabled = true;
}

async function meshCreateAnswer() {
  const offerCode = document.getElementById('meshJoinOfferInput').value.trim();
  if (!offerCode) {
    showToast('Paste the offer code from your peer.');
    return;
  }

  try {
    const offerData = JSON.parse(atob(offerCode));
    if (offerData.type !== 'offer') {
      throw new Error('Invalid offer code.');
    }

    const pc = new RTCPeerConnection(MESH_RTC_CONFIG);
    state.meshCurrentJoin = pc;

    // Listen for data channel
    pc.ondatachannel = (event) => {
      meshSetupDataChannel(event.channel, pc);
    };

    // Gather ICE candidates
    const iceCandidates = [];
    pc.onicecandidate = (e) => {
      if (e.candidate) {
        iceCandidates.push(e.candidate);
      }
    };

    // Set remote description (offer)
    await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: offerData.sdp }));

    // Add ICE candidates from offer
    if (offerData.candidates) {
      for (const c of offerData.candidates) {
        await pc.addIceCandidate(new RTCIceCandidate(c));
      }
    }

    // Create answer
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    // Wait for ICE gathering
    await new Promise((resolve) => {
      if (pc.iceGatheringState === 'complete') {
        resolve();
      } else {
        pc.onicegatheringstatechange = () => {
          if (pc.iceGatheringState === 'complete') resolve();
        };
        setTimeout(resolve, 5000);
      }
    });

    // Encode answer + candidates
    const answerPayload = {
      type: 'answer',
      sdp: pc.localDescription.sdp,
      candidates: iceCandidates.map(c => c.toJSON())
    };
    const answerCode = btoa(JSON.stringify(answerPayload));

    // Show answer code
    document.getElementById('meshAnswerCode').value = answerCode;
    document.getElementById('meshJoinArea').classList.add('hidden');
    document.getElementById('meshAnswerArea').classList.remove('hidden');
    meshSetStatus('connecting', 'Waiting for peer to accept answer...');

    // Handshake timeout
    const timeout = setTimeout(() => {
      if (pc.connectionState !== 'connected' && pc.connectionState !== 'completed') {
        showToast('Connection timed out.');
        meshCancelJoin();
      }
    }, MESH_HANDSHAKE_TIMEOUT);
    pc._meshTimeout = timeout;

  } catch(e) {
    showToast('Invalid offer code: ' + e.message);
  }
}

function meshCopyAnswer() {
  const code = document.getElementById('meshAnswerCode').value;
  navigator.clipboard.writeText(code).then(() => {
    showToast('Answer code copied to clipboard.');
  }).catch(() => {
    document.getElementById('meshAnswerCode').select();
    showToast('Select all and copy the answer code.');
  });
}

function meshCancelJoin() {
  meshCleanupPending();
  document.getElementById('meshJoinArea').classList.add('hidden');
  document.getElementById('meshAnswerArea').classList.add('hidden');
  document.getElementById('meshCreateBtn').disabled = false;
  document.getElementById('meshJoinBtn').disabled = false;
  meshUpdateStatusFromPeers();
}

// ---- Data Channel Setup ----

function meshSetupDataChannel(dc, pc) {
  let peerId = null;

  dc.onopen = () => {
    console.log('FreeLattice Mesh: Data channel open');
    // Send hello
    dc.send(JSON.stringify({
      type: 'hello',
      peerId: state.meshNodeId,
      name: 'Node ' + state.meshNodeId
    }));
  };

  dc.onmessage = (event) => {
    try {
      const msg = JSON.parse(event.data);
      meshHandleMessage(msg, dc, pc);
    } catch(e) {
      console.warn('Mesh: Invalid message', e);
    }
  };

  dc.onclose = () => {
    console.log('FreeLattice Mesh: Data channel closed for peer', peerId);
    if (peerId) {
      meshRemovePeer(peerId);
    }
  };

  dc.onerror = (err) => {
    console.warn('Mesh: Data channel error', err);
  };

  // Monitor connection state
  pc.onconnectionstatechange = () => {
    const connState = pc.connectionState;
    if (connState === 'disconnected' || connState === 'failed' || connState === 'closed') {
      if (peerId) {
        meshRemovePeer(peerId);
      }
    }
  };

  // Store reference for peerId resolution in onmessage
  dc._meshPeerIdRef = (id) => { peerId = id; };
}

function meshHandleMessage(msg, dc, pc) {
  switch (msg.type) {
    case 'hello': {
      const peerId = msg.peerId;
      if (!peerId || peerId === state.meshNodeId) return;

      // Resolve peer ID in data channel
      if (dc._meshPeerIdRef) dc._meshPeerIdRef(peerId);

      // Register peer
      state.meshPeers.set(peerId, {
        pc: pc,
        dc: dc,
        name: msg.name || 'Node ' + peerId,
        connectedAt: Date.now(),
        knowledgeItems: []
      });

      // Clear pending state
      if (state.meshCurrentOffer === pc) state.meshCurrentOffer = null;
      if (state.meshCurrentJoin === pc) state.meshCurrentJoin = null;
      if (pc._meshTimeout) { clearTimeout(pc._meshTimeout); pc._meshTimeout = null; }

      // Hide all code areas
      document.getElementById('meshOfferArea').classList.add('hidden');
      document.getElementById('meshAnswerPasteArea').classList.add('hidden');
      document.getElementById('meshJoinArea').classList.add('hidden');
      document.getElementById('meshAnswerArea').classList.add('hidden');
      document.getElementById('meshCreateBtn').disabled = false;
      document.getElementById('meshJoinBtn').disabled = false;

      meshUpdateStatusFromPeers();
      meshRenderPeerList();
      meshUpdateStats();
      showToast('Connected to peer ' + peerId + '!');

      // Send our knowledge list
      meshSendKnowledgeList(dc);
      break;
    }

    case 'knowledge-list': {
      const peerId = meshFindPeerIdByDc(dc);
      if (!peerId) return;
      const peer = state.meshPeers.get(peerId);
      if (peer) {
        peer.knowledgeItems = msg.items || [];
        state.meshPeerKnowledge.set(peerId, msg.items || []);
        meshRenderPeerKnowledge();
        meshUpdateStats();
      }
      break;
    }

    case 'knowledge-request': {
      // Peer is requesting a specific knowledge item
      const item = state.meshPublishedKnowledge.find(k => k.id === msg.itemId);
      if (item && dc.readyState === 'open') {
        dc.send(JSON.stringify({
          type: 'knowledge-data',
          itemId: item.id,
          name: item.name,
          content: item.content,
          tokens: item.tokens
        }));
      }
      break;
    }

    case 'knowledge-data': {
      // Received knowledge content from peer
      const peerId = meshFindPeerIdByDc(dc);
      meshImportKnowledgeItem(msg.itemId, msg.name, msg.content, msg.tokens, peerId);
      break;
    }

    case 'knowledge-unpublish': {
      const peerId = meshFindPeerIdByDc(dc);
      if (!peerId) return;
      const peer = state.meshPeers.get(peerId);
      if (peer) {
        peer.knowledgeItems = peer.knowledgeItems.filter(k => k.id !== msg.itemId);
        state.meshPeerKnowledge.set(peerId, peer.knowledgeItems);
        meshRenderPeerKnowledge();
        meshUpdateStats();
      }
      break;
    }

    default:
      console.log('Mesh: Unknown message type', msg.type);
  }
}

function meshFindPeerIdByDc(dc) {
  for (const [peerId, peer] of state.meshPeers) {
    if (peer.dc === dc) return peerId;
  }
  return null;
}

// ---- Peer Management ----

function meshRemovePeer(peerId) {
  const peer = state.meshPeers.get(peerId);
  if (peer) {
    try { peer.dc.close(); } catch(e) {}
    try { peer.pc.close(); } catch(e) {}
    state.meshPeers.delete(peerId);
    state.meshPeerKnowledge.delete(peerId);
  }

  // Clear timers
  if (state.meshPeerDurationTimers.has(peerId)) {
    clearInterval(state.meshPeerDurationTimers.get(peerId));
    state.meshPeerDurationTimers.delete(peerId);
  }
  if (state.meshReconnectTimers.has(peerId)) {
    clearTimeout(state.meshReconnectTimers.get(peerId));
    state.meshReconnectTimers.delete(peerId);
  }

  meshUpdateStatusFromPeers();
  meshRenderPeerList();
  meshRenderPeerKnowledge();
  meshUpdateStats();
  showToast('Peer ' + peerId + ' disconnected.');
}

function meshDisconnectPeer(peerId) {
  meshRemovePeer(peerId);
}

function meshCleanupPending() {
  if (state.meshCurrentOffer) {
    if (state.meshCurrentOffer._meshTimeout) clearTimeout(state.meshCurrentOffer._meshTimeout);
    try { state.meshCurrentOffer.close(); } catch(e) {}
    state.meshCurrentOffer = null;
  }
  if (state.meshCurrentJoin) {
    if (state.meshCurrentJoin._meshTimeout) clearTimeout(state.meshCurrentJoin._meshTimeout);
    try { state.meshCurrentJoin.close(); } catch(e) {}
    state.meshCurrentJoin = null;
  }
}

// ---- Knowledge Publishing ----

function meshOpenPublishModal() {
  const optionsDiv = document.getElementById('meshPublishOptions');
  let html = '';

  // Context files
  if (state.contextFiles.length > 0) {
    html += '<div style="font-size: 0.82rem; color: var(--text-secondary); margin-bottom: 8px; font-weight: 500;">Context Files:</div>';
    for (let i = 0; i < state.contextFiles.length; i++) {
      const f = state.contextFiles[i];
      const tokens = estimateTokens(f.content);
      const alreadyPublished = state.meshPublishedKnowledge.some(k => k.name === f.name);
      html += '<label class="publish-option">';
      html += '<input type="checkbox" data-type="file" data-index="' + i + '"' + (alreadyPublished ? ' disabled title="Already published"' : '') + '>';
      html += '<span class="opt-name">' + escapeHtml(f.name) + (alreadyPublished ? ' (published)' : '') + '</span>';
      html += '<span class="opt-tokens">~' + tokens.toLocaleString() + ' tokens</span>';
      html += '</label>';
    }
  }

  // Memory summary
  if (state.memorySummary) {
    const tokens = estimateTokens(state.memorySummary);
    const alreadyPublished = state.meshPublishedKnowledge.some(k => k.name === 'Memory Summary');
    html += '<div style="font-size: 0.82rem; color: var(--text-secondary); margin-bottom: 8px; margin-top: 12px; font-weight: 500;">Memory:</div>';
    html += '<label class="publish-option">';
    html += '<input type="checkbox" data-type="memory"' + (alreadyPublished ? ' disabled title="Already published"' : '') + '>';
    html += '<span class="opt-name">Memory Summary' + (alreadyPublished ? ' (published)' : '') + '</span>';
    html += '<span class="opt-tokens">~' + tokens.toLocaleString() + ' tokens</span>';
    html += '</label>';
  }

  if (!html) {
    html = '<div class="mesh-empty">No context files or memory to publish. Load files in the Chat tab first, or write custom text below.</div>';
  }

  optionsDiv.innerHTML = html;
  document.getElementById('meshPublishCustomName').value = '';
  document.getElementById('meshPublishCustomContent').value = '';
  document.getElementById('meshPublishModal').classList.remove('hidden');
}

function meshClosePublishModal() {
  document.getElementById('meshPublishModal').classList.add('hidden');
}

function meshConfirmPublish() {
  let published = 0;

  // Check selected files
  const checkboxes = document.querySelectorAll('#meshPublishOptions input[type="checkbox"]:checked');
  for (const cb of checkboxes) {
    const type = cb.dataset.type;
    if (type === 'file') {
      const idx = parseInt(cb.dataset.index, 10);
      const f = state.contextFiles[idx];
      if (f && !state.meshPublishedKnowledge.some(k => k.name === f.name)) {
        state.meshPublishedKnowledge.push({
          id: meshGenerateItemId(),
          name: f.name,
          content: f.content,
          tokens: estimateTokens(f.content),
          timestamp: new Date().toISOString()
        });
        published++;
      }
    } else if (type === 'memory') {
      if (!state.meshPublishedKnowledge.some(k => k.name === 'Memory Summary')) {
        state.meshPublishedKnowledge.push({
          id: meshGenerateItemId(),
          name: 'Memory Summary',
          content: state.memorySummary,
          tokens: estimateTokens(state.memorySummary),
          timestamp: new Date().toISOString()
        });
        published++;
      }
    }
  }

  // Check custom text
  const customName = document.getElementById('meshPublishCustomName').value.trim();
  const customContent = document.getElementById('meshPublishCustomContent').value.trim();
  if (customContent) {
    const name = customName || 'Custom Note (' + new Date().toLocaleTimeString() + ')';
    state.meshPublishedKnowledge.push({
      id: meshGenerateItemId(),
      name: name,
      content: customContent,
      tokens: estimateTokens(customContent),
      timestamp: new Date().toISOString()
    });
    published++;
  }

  if (published > 0) {
    meshSavePublished();
    meshRenderMyKnowledge();
    meshBroadcastKnowledgeList();
    meshUpdateStats();
    showToast('Published ' + published + ' knowledge item(s) to the mesh.');
  } else {
    showToast('No items selected to publish.');
  }

  meshClosePublishModal();
}

function meshUnpublish(itemId) {
  state.meshPublishedKnowledge = state.meshPublishedKnowledge.filter(k => k.id !== itemId);
  meshSavePublished();
  meshRenderMyKnowledge();
  meshUpdateStats();

  // Notify all peers
  for (const [peerId, peer] of state.meshPeers) {
    if (peer.dc.readyState === 'open') {
      peer.dc.send(JSON.stringify({ type: 'knowledge-unpublish', itemId: itemId }));
    }
  }
  meshBroadcastKnowledgeList();
  showToast('Knowledge unpublished.');
}

// ---- Knowledge Exchange ----

function meshSendKnowledgeList(dc) {
  if (dc.readyState !== 'open') return;
  const items = state.meshPublishedKnowledge.map(k => ({
    id: k.id,
    name: k.name,
    tokens: k.tokens,
    timestamp: k.timestamp
  }));
  dc.send(JSON.stringify({ type: 'knowledge-list', items: items }));
}

function meshBroadcastKnowledgeList() {
  for (const [peerId, peer] of state.meshPeers) {
    meshSendKnowledgeList(peer.dc);
  }
}

function meshRequestKnowledge(peerId, itemId) {
  const peer = state.meshPeers.get(peerId);
  if (!peer || peer.dc.readyState !== 'open') {
    showToast('Peer is not connected.');
    return;
  }
  peer.dc.send(JSON.stringify({ type: 'knowledge-request', itemId: itemId }));
  showToast('Requesting knowledge from peer ' + peerId + '...');
}

function meshImportKnowledgeItem(itemId, name, content, tokens, sourcePeerId) {
  if (state.meshImportedItems.has(itemId)) {
    showToast('"' + name + '" is already imported.');
    return;
  }

  // Add to context files with mesh label
  const meshName = '\u{1F310} [' + (sourcePeerId || '???') + '] ' + name;
  if (state.contextFiles.some(f => f.name === meshName)) {
    showToast('"' + name + '" is already in context.');
    return;
  }

  state.contextFiles.push({
    name: meshName,
    size: (content || '').length,
    content: content || '',
    active: true,
    summary: null,
    summaryContent: null,
    useSummary: false,
    meshSource: sourcePeerId || 'unknown',
    meshItemId: itemId
  });

  state.meshImportedItems.add(itemId);
  renderFileList();
  updateContextBudget();
  meshUpdateStats();
  showToast('Imported "' + name + '" from peer ' + (sourcePeerId || '???') + ' into context.');
}

function meshImportFromPeer(peerId, itemId) {
  meshRequestKnowledge(peerId, itemId);
}

function meshImportAll() {
  for (const [peerId, items] of state.meshPeerKnowledge) {
    for (const item of items) {
      if (!state.meshImportedItems.has(item.id)) {
        meshRequestKnowledge(peerId, item.id);
      }
    }
  }
}

// ---- Status & Rendering ----

function meshSetStatus(status, text) {
  const indicator = document.getElementById('meshStatusIndicator');
  const dot = document.getElementById('meshStatusDot');
  const textEl = document.getElementById('meshStatusText');

  indicator.className = 'mesh-status-indicator ' + status;
  dot.className = 'status-dot' + (status === 'connected' ? ' ready' : status === 'connecting' ? ' working' : '');
  textEl.textContent = text;
}

function meshUpdateStatusFromPeers() {
  const count = state.meshPeers.size;
  if (count === 0) {
    meshSetStatus('disconnected', 'Disconnected');
  } else {
    meshSetStatus('connected', 'Connected to ' + count + ' peer' + (count > 1 ? 's' : ''));
  }
}

function meshRenderPeerList() {
  const section = document.getElementById('meshPeerSection');
  const list = document.getElementById('meshPeerList');

  if (state.meshPeers.size === 0) {
    section.style.display = 'none';
    return;
  }

  section.style.display = '';
  let html = '';

  for (const [peerId, peer] of state.meshPeers) {
    const duration = meshFormatDuration(Date.now() - peer.connectedAt);
    html += '<div class="mesh-peer-item">';
    html += '<div class="peer-info">';
    html += '<span class="status-dot ready"></span>';
    html += '<span class="peer-id">' + escapeHtml(peerId) + '</span>';
    html += '<span class="peer-name">' + escapeHtml(peer.name) + '</span>';
    html += '<span class="peer-duration">' + duration + '</span>';
    html += '</div>';
    html += '<button class="peer-disconnect" onclick="meshDisconnectPeer(\'' + escapeHtml(peerId) + '\')">Disconnect</button>';
    html += '</div>';
  }

  list.innerHTML = html;

  // Start duration timer if not already running
  for (const [peerId] of state.meshPeers) {
    if (!state.meshPeerDurationTimers.has(peerId)) {
      const timer = setInterval(() => meshRenderPeerList(), 30000); // Update every 30s
      state.meshPeerDurationTimers.set(peerId, timer);
    }
  }
}

function meshRenderMyKnowledge() {
  const list = document.getElementById('meshMyKnowledgeList');
  if (state.meshPublishedKnowledge.length === 0) {
    list.innerHTML = '<div class="mesh-empty">No knowledge published yet. Click "Publish Knowledge" to share with peers.</div>';
    return;
  }

  list.innerHTML = state.meshPublishedKnowledge.map(k => {
    const time = new Date(k.timestamp).toLocaleString();
    return '<div class="mesh-knowledge-item">' +
      '<span class="knowledge-name">&#128218; ' + escapeHtml(k.name) + '</span>' +
      '<span class="knowledge-meta">~' + (k.tokens || 0).toLocaleString() + ' tokens</span>' +
      '<span class="knowledge-meta">' + time + '</span>' +
      '<div class="knowledge-actions">' +
        '<button class="unpublish-btn" onclick="meshUnpublish(\'' + k.id + '\')" title="Unpublish">&#10005; Unpublish</button>' +
      '</div>' +
    '</div>';
  }).join('');
}

function meshRenderPeerKnowledge() {
  const list = document.getElementById('meshPeerKnowledgeList');
  const importAllRow = document.getElementById('meshImportAllRow');
  let allItems = [];

  for (const [peerId, items] of state.meshPeerKnowledge) {
    for (const item of items) {
      allItems.push({ ...item, peerId: peerId });
    }
  }

  if (allItems.length === 0) {
    list.innerHTML = '<div class="mesh-empty">No peer knowledge available. Connect to peers to discover shared knowledge.</div>';
    importAllRow.style.display = 'none';
    return;
  }

  importAllRow.style.display = '';

  list.innerHTML = allItems.map(item => {
    const imported = state.meshImportedItems.has(item.id);
    return '<div class="mesh-knowledge-item">' +
      '<span class="knowledge-name">&#128218; ' + escapeHtml(item.name) + '</span>' +
      '<span class="knowledge-meta">~' + (item.tokens || 0).toLocaleString() + ' tokens</span>' +
      '<span class="knowledge-source">from ' + escapeHtml(item.peerId) + '</span>' +
      '<div class="knowledge-actions">' +
        (imported
          ? '<button disabled style="color: var(--success); border-color: var(--success);">&#10003; Imported</button>'
          : '<button class="import-btn" onclick="meshImportFromPeer(\'' + escapeHtml(item.peerId) + '\', \'' + item.id + '\')" title="Import to context">&#8615; Import</button>'
        ) +
      '</div>' +
    '</div>';
  }).join('');
}

function meshUpdateStats() {
  document.getElementById('meshStatPeers').textContent = state.meshPeers.size;
  document.getElementById('meshStatPublished').textContent = state.meshPublishedKnowledge.length;

  let peerItemCount = 0;
  for (const [, items] of state.meshPeerKnowledge) {
    peerItemCount += items.length;
  }
  document.getElementById('meshStatAvailable').textContent = peerItemCount;
  document.getElementById('meshStatImported').textContent = state.meshImportedItems.size;
}

function meshFormatDuration(ms) {
  const sec = Math.floor(ms / 1000);
  if (sec < 60) return sec + 's';
  const min = Math.floor(sec / 60);
  if (min < 60) return min + 'm';
  const hr = Math.floor(min / 60);
  return hr + 'h ' + (min % 60) + 'm';
}

// Close publish modal on overlay click
document.addEventListener('click', (e) => {
  if (e.target.id === 'meshPublishModal') meshClosePublishModal();
});

// ---- Service Worker Registration ----
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/FreeLattice/sw.js')
    .then(reg => console.log('FreeLattice: Offline mode ready'))
    .catch(err => console.log('FreeLattice: Service worker not available'));
}
</script>

</body>
</html>
